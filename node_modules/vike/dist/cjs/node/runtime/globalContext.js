"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.vikeConfigErrorRecoverMsg = void 0;
exports.getGlobalContext = getGlobalContext;
exports.getGlobalContextSync = getGlobalContextSync;
exports.getGlobalContextAsync = getGlobalContextAsync;
exports.getGlobalContextServerInternal = getGlobalContextServerInternal;
exports.getViteDevServer = getViteDevServer;
exports.getViteConfig = getViteConfig;
exports.initGlobalContext_renderPage = initGlobalContext_renderPage;
exports.initGlobalContext_runPrerender = initGlobalContext_runPrerender;
exports.initGlobalContext_getPagesAndRoutes = initGlobalContext_getPagesAndRoutes;
exports.setGlobalContext_viteDevServer = setGlobalContext_viteDevServer;
exports.setGlobalContext_viteConfig = setGlobalContext_viteConfig;
exports.setGlobalContext_isPrerendering = setGlobalContext_isPrerendering;
exports.setGlobalContext_isProductionAccordingToVite = setGlobalContext_isProductionAccordingToVite;
exports.setGlobalContext_prodBuildEntry = setGlobalContext_prodBuildEntry;
exports.clearGlobalContext = clearGlobalContext;
exports.assertBuildInfo = assertBuildInfo;
exports.updateUserFiles = updateUserFiles;
// The core logic revolves around:
// - virtualFileExportsGlobalEntry is the main requirement
// - In production: globalObject.prodBuildEntry which is the production entry set by @brillout/vite-plugin-server-entry
//   - loadProdBuildEntry() sets globalObject.prodBuildEntry and then sets virtualFileExportsGlobalEntry
//   - With vike-server it's set at server start: @brillout/vite-plugin-server-entry injects `import './entry.mjs'` (the production entry generated by @brillout/vite-plugin-server-entry) as first line of code of dist/server/index.mjs while dist/server/entry.mjs calls setGlobalContext_prodBuildEntry()
//   - Without vike-server it's manually loaded here using importServerProductionEntry() which uses @brillout/vite-plugin-server-entry's autoImporter or crawler
// - In development: globalObject.viteDevServer which is Vite's development server
//   - globalObject.viteDevServer is used by updateUserFiles() which then sets virtualFileExportsGlobalEntry
const utils_js_1 = require("./utils.js");
const runtime_1 = require("@brillout/vite-plugin-server-entry/runtime");
const virtualFileId_js_1 = require("../shared/virtualFileId.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const loadPageRoutes_js_1 = require("../../shared/route/loadPageRoutes.js");
const assertV1Design_js_1 = require("../shared/assertV1Design.js");
const resolveBase_js_1 = require("../shared/resolveBase.js");
const createGlobalContextShared_js_1 = require("../../shared/createGlobalContextShared.js");
const prepareGlobalContextForPublicUsage_js_1 = require("../../shared/prepareGlobalContextForPublicUsage.js");
const loggerRuntime_js_1 = require("./loggerRuntime.js");
const getVikeConfigError_js_1 = require("../shared/getVikeConfigError.js");
const isNewError_js_1 = require("./renderPage/isNewError.js");
const context_js_1 = require("../api/context.js");
const debug = (0, utils_js_1.createDebugger)('vike:globalContext');
const globalObject = (0, utils_js_1.getGlobalObject)('runtime/globalContext.ts', getInitialGlobalObject());
// Trick to break down TypeScript circular dependency
// https://chat.deepseek.com/a/chat/s/d7e9f90a-c7f3-4108-9cd5-4ad6caed3539
const globalObjectTyped = globalObject;
const vikeConfigErrorRecoverMsg = picocolors_1.default.bold(picocolors_1.default.green('Vike config loaded'));
exports.vikeConfigErrorRecoverMsg = vikeConfigErrorRecoverMsg;
(0, utils_js_1.assertIsNotBrowser)();
async function getGlobalContextServerInternal() {
    // getGlobalContextServerInternal() should always be called after initGlobalContext()
    (0, utils_js_1.assert)(globalObject.isInitialized);
    assertGlobalContextIsDefined();
    if (!isProd())
        await globalObject.waitForUserFilesUpdate;
    const { globalContext } = globalObjectTyped;
    assertIsDefined(globalContext);
    return { globalContext };
}
function assertIsDefined(globalContext) {
    if (!globalContext) {
        debug('globalContext', globalContext);
        debug('assertIsDefined()', new Error().stack);
        (0, utils_js_1.assert)(false);
    }
}
function assertGlobalContextIsDefined() {
    assertIsDefined(globalObjectTyped.globalContext);
    (0, utils_js_1.assert)(globalObject.globalContext);
}
// We purposely return GlobalContext instead of GlobalContextServer because `import { getGlobalContext } from 'vike'` can resolve to the client-side implementation.
/**
 * Get runtime information about your app.
 *
 * https://vike.dev/getGlobalContext
 */
async function getGlobalContext() {
    debug('getGlobalContext()');
    const isProduction = isProdOptional();
    // This assertion cannot fail for vike-server users (because when using vike-server it's guaranteed that globalObject.isProduction is set before executing any user-land code and any Vike extension code).
    (0, utils_js_1.assertUsage)(isProduction !== null, "The global context isn't set yet, use getGlobalContextAsync() instead.");
    return await getGlobalContextAsync(isProduction);
}
/**
 * Get runtime information about your app.
 *
 * https://vike.dev/getGlobalContext
 */
async function getGlobalContextAsync(isProduction) {
    debug('getGlobalContextAsync()');
    (0, utils_js_1.assertUsage)(typeof isProduction === 'boolean', `[getGlobalContextAsync(isProduction)] Argument ${picocolors_1.default.cyan('isProduction')} ${isProduction === undefined ? 'is missing' : `should be ${picocolors_1.default.cyan('true')} or ${picocolors_1.default.cyan('false')}`}`);
    globalObject.isProductionAccordingToUser = isProduction;
    if (!globalObject.globalContext)
        await initGlobalContext_getGlobalContextAsync();
    if (!isProduction)
        await globalObject.waitForUserFilesUpdate;
    assertGlobalContextIsDefined();
    return getGlobalContextForPublicUsage();
}
/**
 * Get runtime information about your app.
 *
 * https://vike.dev/getGlobalContext
 */
function getGlobalContextSync() {
    debug('getGlobalContextSync()');
    const { globalContext } = globalObjectTyped;
    (0, utils_js_1.assertUsage)(globalContext, createGlobalContextShared_js_1.getGlobalContextSyncErrMsg);
    (0, utils_js_1.assertWarning)(isProd(), 
    // - We discourage users from using it in development because `pageContext.globalContext` is safer: I ain't sure but there could be race conditions when using `getGlobalContextSync()` inside React/Vue components upon HMR.
    // - I don't see any issues with getGlobalContextSync() in production.
    // - getGlobalContextSync() is used in production by vike-vercel
    //   - https://discord.com/channels/@me/942519153502339072/1389546794676916344 (PM between Rom and Joël)
    "getGlobalContextSync() shouldn't be used in development, see https://vike.dev/getGlobalContext", { onlyOnce: true });
    return getGlobalContextForPublicUsage();
}
function getGlobalContextForPublicUsage() {
    const { globalContext } = globalObjectTyped;
    (0, utils_js_1.assert)(globalContext);
    const globalContextForPublicUsage = (0, prepareGlobalContextForPublicUsage_js_1.prepareGlobalContextForPublicUsage)(globalContext);
    return globalContextForPublicUsage;
}
async function setGlobalContext_viteDevServer(viteDevServer) {
    debug('setGlobalContext_viteDevServer()');
    // We cannot cache globalObject.viteDevServer because it's fully replaced when the user modifies vite.config.js => Vite's dev server is fully reloaded and a new viteDevServer replaces the previous one.
    if (!globalObject.viteDevServer) {
        assertIsNotInitializedYet();
    }
    (0, utils_js_1.assert)(globalObject.viteConfig);
    globalObject.viteDevServer = viteDevServer;
    globalObject.viteDevServerPromiseResolve(viteDevServer);
    if (isRunnable(viteDevServer)) {
        const { success } = await updateUserFiles();
        if (!success)
            return;
        assertGlobalContextIsDefined();
    }
}
function setGlobalContext_viteConfig(viteConfig, viteConfigRuntime) {
    if (globalObject.viteConfig)
        return;
    assertIsNotInitializedYet();
    globalObject.viteConfig = viteConfig;
    globalObject.viteConfigRuntime = viteConfigRuntime;
}
function assertIsNotInitializedYet() {
    // In development, globalObject.viteDevServer always needs to be awaited for before initializing globalObject.globalContext
    (0, utils_js_1.assert)(!globalObject.globalContext);
}
function setGlobalContext_isPrerendering() {
    globalObject.isPrerendering = true;
}
function setGlobalContext_isProductionAccordingToVite(isProductionAccordingToVite) {
    globalObject.isProductionAccordingToVite = isProductionAccordingToVite;
}
function getViteDevServer() {
    return globalObject.viteDevServer ?? null;
}
function getViteConfig() {
    return globalObject.viteConfig ?? null;
}
async function initGlobalContext_renderPage() {
    debug('initGlobalContext_renderPage()');
    globalObject.isAfterFirstRenderPageCall = true;
    await initGlobalContext();
}
async function initGlobalContext_runPrerender() {
    debug('initGlobalContext_runPrerender()');
    (0, utils_js_1.assert)(globalObject.isPrerendering === true);
    (0, utils_js_1.assert)(isProd());
    if (globalObject.initGlobalContext_runPrerender_alreadyCalled)
        return;
    globalObject.initGlobalContext_runPrerender_alreadyCalled = true;
    (0, utils_js_1.assert)(globalObject.isPrerendering);
    (0, utils_js_1.assert)(globalObject.viteConfig);
    // We assume initGlobalContext_runPrerender() to be called before:
    // - initGlobalContext_renderPage()
    // - initGlobalContext_getGlobalContextAsync()
    assertIsNotInitializedYet();
    await initGlobalContext();
}
async function initGlobalContext_getGlobalContextAsync() {
    debug('initGlobalContext_getGlobalContextAsync()');
    await initGlobalContext();
}
async function initGlobalContext_getPagesAndRoutes() {
    debug('initGlobalContext_getPagesAndRoutes()');
    globalObject.isProductionAccordingToPhotonVercel = true;
    await initGlobalContext();
}
async function initGlobalContext() {
    const isProduction = isProd();
    if (!isProduction) {
        if (isProcessSharedWithVite()) {
            await globalObject.viteDevServerPromise;
        }
        else {
            (0, utils_js_1.assert)((0, utils_js_1.isNonRunnableDev)());
            await updateUserFiles();
        }
        (0, utils_js_1.assert)(globalObject.waitForUserFilesUpdate);
        await globalObject.waitForUserFilesUpdate;
    }
    else {
        await loadProdBuildEntry(globalObject.viteConfigRuntime?.build.outDir);
    }
    assertGlobalContextIsDefined();
    globalObject.isInitialized = true;
}
function assertViteManifest(manifest) {
    (0, utils_js_1.assert)((0, utils_js_1.isPlainObject)(manifest));
    /* We should include these assertions but we don't as a workaround for PWA manifests: https://github.com/vikejs/vike/issues/769
       Instead, we should rename the vite manifest e.g. with https://vitejs.dev/config/build-options.html#build-manifest
    Object.entries(manifest)
      // circumvent esbuild bug: esbuild adds a `default` key to JSON upon `require('./some.json')`.
      .filter(([key]) => key !== 'default')
      .forEach(([_, entry]) => {
        assert(isPlainObject(entry))
        assert(typeof entry.file === 'string')
      })
    */
}
async function loadProdBuildEntry(outDir) {
    debug('loadProdBuildEntry()');
    if (globalObject.globalContext) {
        debug('loadProdBuildEntry() - already done');
        return;
    }
    if (!globalObject.prodBuildEntry) {
        debug('importServerProductionEntry()');
        // importServerProductionEntry() loads dist/server/entry.mjs which calls setGlobalContext_prodBuildEntry()
        await (0, runtime_1.importServerProductionEntry)({ outDir });
        if (!globalObject.prodBuildEntry) {
            debug('globalObject.prodBuildEntryPrevious');
            // Needed, for example, when calling the API prerender() then preview() because both trigger a importServerProductionEntry() call but only the first only is applied because of the import() cache. (A proper implementation would be to clear the import() cache, but it probably isn't possible on platforms such as Cloudflare Workers.)
            globalObject.prodBuildEntry = globalObject.prodBuildEntryPrevious;
        }
        (0, utils_js_1.assert)(globalObject.prodBuildEntry);
        // If using `inject` then dist/server/index.js imports dist/server/entry.js and loadProdBuildEntry() isn't needed.
        // If dist/server/entry.js isn't imported then this means the user is running the original server entry `$ ts-node server/index.ts`.
        (0, utils_js_1.assertWarning)(
        // vike-server => `inject === true`
        // vike-node => `inject === [ 'index' ]` => we don't show the warning to vike-node users (I don't remember why).
        globalObject.buildInfo?.viteConfigRuntime.vitePluginServerEntry.inject !== true || globalObject.isPrerendering, `Run the built server entry (e.g. ${picocolors_1.default.cyan('$ node dist/server/index.mjs')}) instead of the original server entry (e.g. ${picocolors_1.default.cyan('$ ts-node server/index.ts')})`, { onlyOnce: true });
    }
    const { prodBuildEntry } = globalObject;
    assertProdBuildEntry(prodBuildEntry);
    globalObject.assetsManifest = prodBuildEntry.assetsManifest;
    globalObject.buildInfo = prodBuildEntry.buildInfo;
    await createGlobalContext(prodBuildEntry.virtualFileExportsGlobalEntry);
}
// This is the production entry, see:
// https://github.com/vikejs/vike/blob/8c350e8105a626469e87594d983090919e82099b/packages/vike/node/vite/plugins/pluginBuild/pluginProdBuildEntry.ts#L47
async function setGlobalContext_prodBuildEntry(prodBuildEntry) {
    debug('setGlobalContext_prodBuildEntry()');
    assertProdBuildEntry(prodBuildEntry);
    globalObject.prodBuildEntry = prodBuildEntry;
    globalObject.prodBuildEntryPrevious = prodBuildEntry;
    (0, utils_js_1.assert)(globalObject.prodBuildEntry); // ensure no infinite loop
    await loadProdBuildEntry();
    assertGlobalContextIsDefined();
    debug('setGlobalContext_prodBuildEntry() - done');
}
function assertProdBuildEntry(prodBuildEntry) {
    (0, utils_js_1.assert)((0, utils_js_1.isObject)(prodBuildEntry));
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(prodBuildEntry, 'virtualFileExportsGlobalEntry', 'object'));
    const { virtualFileExportsGlobalEntry } = prodBuildEntry;
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(prodBuildEntry, 'assetsManifest', 'object'));
    const { assetsManifest } = prodBuildEntry;
    assertViteManifest(assetsManifest);
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(prodBuildEntry, 'buildInfo', 'object'));
    const { buildInfo } = prodBuildEntry;
    assertBuildInfo(buildInfo);
    (0, utils_js_1.checkType)({ virtualFileExportsGlobalEntry, assetsManifest, buildInfo });
}
function assertBuildInfo(buildInfo) {
    (0, utils_js_1.assert)((0, utils_js_1.isObject)(buildInfo));
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(buildInfo, 'versionAtBuildTime', 'string'));
    assertVersionAtBuildTime(buildInfo.versionAtBuildTime);
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(buildInfo, 'viteConfigRuntime', 'object'));
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(buildInfo.viteConfigRuntime, '_baseViteOriginal', 'string'));
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(buildInfo.viteConfigRuntime, 'root', 'string'));
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(buildInfo.viteConfigRuntime, 'build', 'object'));
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(buildInfo.viteConfigRuntime.build, 'outDir', 'string'));
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(buildInfo.viteConfigRuntime, 'vitePluginServerEntry', 'object'));
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(buildInfo, 'usesClientRouter', 'boolean'));
}
function assertVersionAtBuildTime(versionAtBuildTime) {
    const versionAtRuntime = utils_js_1.PROJECT_VERSION;
    const pretty = (version) => picocolors_1.default.bold(`vike@${version}`);
    (0, utils_js_1.assertUsage)(versionAtBuildTime === versionAtRuntime, `Re-build your app (you're using ${pretty(versionAtRuntime)} but your app was built with ${pretty(versionAtBuildTime)})`);
}
async function updateUserFiles() {
    debug('updateUserFiles()');
    (0, utils_js_1.assert)(!isProd());
    const { promise, resolve } = (0, utils_js_1.genPromise)();
    globalObject.waitForUserFilesUpdate = promise;
    globalObject.waitForUserFilesUpdateResolve ?? (globalObject.waitForUserFilesUpdateResolve = []);
    globalObject.waitForUserFilesUpdateResolve.push(resolve);
    const onError = (err) => {
        if (!(0, isNewError_js_1.hasAlreadyLogged)(err)) {
            (0, loggerRuntime_js_1.logRuntimeError)(err, null);
        }
        (0, getVikeConfigError_js_1.setVikeConfigError)({ errorRuntime: { err } });
        globalObject.vikeConfigHasRuntimeError = true;
        return { success: false };
    };
    const onSuccess = () => {
        if (globalObject.vikeConfigHasRuntimeError) {
            (0, utils_js_1.assert)(loggerRuntime_js_1.logRuntimeInfo); // always defined in dev
            (0, loggerRuntime_js_1.logRuntimeInfo)(vikeConfigErrorRecoverMsg, null, 'error-recover');
        }
        globalObject.vikeConfigHasRuntimeError = false;
        (0, getVikeConfigError_js_1.setVikeConfigError)({ errorRuntime: false });
        globalObject.waitForUserFilesUpdateResolve.forEach((resolve) => resolve());
        globalObject.waitForUserFilesUpdateResolve = [];
        resolve();
        return { success: true };
    };
    const isOutdated = () => 
    // There is a newer call — let the new call supersede the old one.
    // We deliberately swallow the intermetidate state (including any potential error) — it's now outdated and has existed only for a very short period of time.
    globalObject.waitForUserFilesUpdate !== promise ||
        // Avoid race condition: abort if there is a new globalObject.viteDevServer (happens when vite.config.js is modified => Vite's dev server is fully reloaded).
        viteDevServer !== globalObject.viteDevServer;
    const { viteDevServer } = globalObject;
    let hasError = false;
    let virtualFileExportsGlobalEntry;
    let err;
    if (viteDevServer) {
        (0, utils_js_1.assert)(isRunnable(viteDevServer));
        /* We don't use runner.import() yet, because as of vite@7.0.6 (July 2025) runner.import() unexpectedly invalidates the module graph, which is a unexpected behavior that doesn't happen with ssrLoadModule()
        // Vite 6
        try {
          virtualFileExportsGlobalEntry = await (viteDevServer.environments.ssr as RunnableDevEnvironment).runner.import(
            'virtual:vike:global-entry:server',
          )
        } catch (err_) {
          hasError = true
          err = err_
        }
        */
        // Vite 5
        try {
            virtualFileExportsGlobalEntry = await viteDevServer.ssrLoadModule(virtualFileId_js_1.virtualFileIdGlobalEntryServer);
        }
        catch (err_) {
            hasError = true;
            err = err_;
        }
    }
    else {
        try {
            /* We use __VIKE__DYNAMIC_IMPORT instead of directly using import() to workaround what seems to be a Vite HMR bug:
               ```js
               assert(false)
               // This line breaks the HMR of regular (runnable) apps, even though (as per the assert() above) it's never run. It seems to be a Vite bug: handleHotUpdate() receives an empty `modules` list.
               import('virtual:vike:global-entry:server')
               ```
            */
            virtualFileExportsGlobalEntry = await __VIKE__DYNAMIC_IMPORT('virtual:vike:global-entry:server');
        }
        catch (err_) {
            hasError = true;
            err = err_;
        }
    }
    if (isOutdated())
        return { success: false };
    if (hasError)
        return onError(err);
    virtualFileExportsGlobalEntry = virtualFileExportsGlobalEntry.default || virtualFileExportsGlobalEntry;
    if ((0, getVikeConfigError_js_1.getVikeConfigErrorBuild)()) {
        return { success: false };
    }
    try {
        await createGlobalContext(virtualFileExportsGlobalEntry);
    }
    catch (err_) {
        hasError = true;
        err = err_;
    }
    if (isOutdated())
        return { success: false };
    if (hasError)
        return onError(err);
    return onSuccess();
}
async function createGlobalContext(virtualFileExportsGlobalEntry) {
    debug('createGlobalContext()');
    (0, utils_js_1.assert)(!(0, getVikeConfigError_js_1.getVikeConfigErrorBuild)());
    const globalContextPromise = (0, createGlobalContextShared_js_1.createGlobalContextShared)(virtualFileExportsGlobalEntry, globalObject, addGlobalContext, addGlobalContextTmp, addGlobalContextAsync);
    debug('createGlobalContext() - done [sync]');
    // We define an early globalContext version synchronously, so that getGlobalContextSync() can be called early.
    // - Required by vike-vercel
    (0, utils_js_1.assert)(globalObject.globalContext);
    const globalContext = await globalContextPromise;
    debug('createGlobalContext() - done [async]');
    (0, assertV1Design_js_1.assertV1Design)(
    // pageConfigs is PageConfigRuntime[] but assertV1Design() requires PageConfigBuildTime[]
    globalContext._pageConfigs.length > 0, globalContext._pageFilesAll);
    assertGlobalContextIsDefined();
    (0, utils_js_1.onSetupRuntime)();
    // Never actually used, only used for TypeScript `ReturnType<typeof createGlobalContext>`
    return globalContext;
}
async function addGlobalContextTmp(globalContext) {
    debug('addGlobalContextTmp()');
    const { pageRoutes, onBeforeRouteHook } = await (0, loadPageRoutes_js_1.loadPageRoutes)(globalContext._pageFilesAll, globalContext._pageConfigs, globalContext._pageConfigGlobal, globalContext._allPageIds);
    return addGlobalContextCommon(globalContext, pageRoutes, onBeforeRouteHook);
}
function addGlobalContext(globalContext) {
    debug('addGlobalContext()');
    const { pageRoutes, onBeforeRouteHook } = (0, loadPageRoutes_js_1.loadPageRoutesSync)(globalContext._pageFilesAll, globalContext._pageConfigs, globalContext._pageConfigGlobal, globalContext._allPageIds);
    return addGlobalContextCommon(globalContext, pageRoutes, onBeforeRouteHook);
}
function addGlobalContextCommon(globalContext, pageRoutes, onBeforeRouteHook) {
    const globalContextBase = {
        isClientSide: false,
        _pageRoutes: pageRoutes,
        _onBeforeRouteHook: onBeforeRouteHook,
    };
    const { viteDevServer, viteConfig, isPrerendering } = globalObject;
    const isProduction = isProd();
    if (!isProduction) {
        (0, utils_js_1.assert)(globalContext); // main common requirement
        (0, utils_js_1.assert)(!isPrerendering);
        return {
            ...globalContextBase,
            _isProduction: false,
            _isPrerendering: false,
            assetsManifest: null,
            _viteDevServer: viteDevServer,
            viteConfig,
        };
    }
    else {
        (0, utils_js_1.assert)(globalObject.prodBuildEntry);
        (0, utils_js_1.assert)(globalContext); // main common requiement
        const { buildInfo, assetsManifest } = globalObject;
        (0, utils_js_1.assert)(buildInfo);
        (0, utils_js_1.assert)(assetsManifest);
        const globalContextBase2 = {
            ...globalContextBase,
            _isProduction: true,
            assetsManifest,
            _viteDevServer: null,
            _usesClientRouter: buildInfo.usesClientRouter,
        };
        if (isPrerendering) {
            (0, utils_js_1.assert)(viteConfig);
            return {
                ...globalContextBase2,
                _isPrerendering: true,
                viteConfig,
            };
        }
        else {
            return {
                ...globalContextBase2,
                _isPrerendering: false,
                viteConfig: null,
            };
        }
    }
}
async function addGlobalContextAsync(globalContext) {
    debug('addGlobalContextAsync()');
    let { viteConfigRuntime, buildInfo } = globalObject;
    if (!viteConfigRuntime) {
        if (buildInfo) {
            viteConfigRuntime = buildInfo.viteConfigRuntime;
        }
        else {
            (0, utils_js_1.assert)(!isProcessSharedWithVite()); // process shared with Vite => globalObject.viteConfigRuntime should be set
            (0, utils_js_1.assert)(!isProd()); // production => globalObject.buildInfo.viteConfigRuntime should be set
            (0, utils_js_1.assert)((0, utils_js_1.isNonRunnableDev)());
            const rpc = (0, utils_js_1.getViteRPC)();
            viteConfigRuntime = await rpc.getViteConfigRuntimeRPC();
        }
    }
    (0, utils_js_1.assert)(viteConfigRuntime);
    return {
        viteConfigRuntime,
        ...resolveBaseRuntime(viteConfigRuntime, globalContext.config),
    };
}
function clearGlobalContext() {
    debug('clearGlobalContext()');
    (0, utils_js_1.objectReplace)(globalObject, getInitialGlobalObject(), ['prodBuildEntryPrevious']);
}
function getInitialGlobalObject() {
    debug('getInitialGlobalObject()');
    const { promise: viteDevServerPromise, resolve: viteDevServerPromiseResolve } = (0, utils_js_1.genPromise)();
    return {
        viteDevServerPromise,
        viteDevServerPromiseResolve,
    };
}
function resolveBaseRuntime(viteConfigRuntime, config) {
    const baseViteOriginal = viteConfigRuntime._baseViteOriginal;
    const baseServerUnresolved = config.baseServer ?? null;
    const baseAssetsUnresolved = config.baseAssets ?? null;
    return (0, resolveBase_js_1.resolveBase)(baseViteOriginal, baseServerUnresolved, baseAssetsUnresolved);
}
function isProcessSharedWithVite() {
    const yes = globalThis.__VIKE__IS_PROCESS_SHARED_WITH_VITE ?? false;
    if (yes)
        (0, utils_js_1.assert)(!(0, utils_js_1.isNonRunnableDev)());
    return yes;
}
function isRunnable(viteDevServer) {
    const yes = 
    // Vite 5
    !viteDevServer.environments ||
        // Vite 6 or above
        (0, utils_js_1.isRunnableDevEnvironment)(viteDevServer.environments.ssr);
    if (yes)
        (0, utils_js_1.assert)(!(0, utils_js_1.isNonRunnableDev)());
    return yes;
}
function isProd() {
    const isProduction = isProdOptional();
    if (isProduction === null) {
        if (globalObject.isAfterFirstRenderPageCall) {
            // When using a production server without vike-server, there isn't any reliable signal we can use to determine early whether the environment is production or development. If renderPage() was called then some non-negligible amount of time passed — it's likely that, in dev, one of the Vite hooks should have already sent a signal we can use to determine prod/dev.
            return true;
        }
        else {
            (0, utils_js_1.assert)(false);
        }
    }
    return isProduction;
}
function isProdOptional() {
    const vikeApiOperation = (0, context_js_1.getVikeApiOperation)()?.operation ?? null;
    const yes = 
    // setGlobalContext_prodBuildEntry() was called
    !!globalObject.prodBuildEntry ||
        globalObject.isPrerendering === true ||
        // Vike CLI & Vike API
        (!!vikeApiOperation && vikeApiOperation !== 'dev') ||
        // Vite command
        globalObject.isProductionAccordingToVite === true ||
        // getGlobalContextAsync(isProduction)
        globalObject.isProductionAccordingToUser === true ||
        // vite-plugin-vercel
        globalObject.isProductionAccordingToPhotonVercel === true;
    (0, utils_js_1.assert)(typeof yes === 'boolean');
    const no = !!globalObject.viteDevServer ||
        // Vike CLI & Vike API
        vikeApiOperation === 'dev' ||
        // Vite command
        globalObject.isProductionAccordingToVite === false ||
        // getGlobalContextAsync(isProduction)
        globalObject.isProductionAccordingToUser === false ||
        // @cloudflare/vite-plugin
        (0, utils_js_1.isNonRunnableDev)() === true;
    (0, utils_js_1.assert)(typeof no === 'boolean');
    if (yes) {
        (0, utils_js_1.assert)(no === false);
        return true;
    }
    if (no) {
        (0, utils_js_1.assert)(yes === false);
        return false;
    }
    return null;
}
