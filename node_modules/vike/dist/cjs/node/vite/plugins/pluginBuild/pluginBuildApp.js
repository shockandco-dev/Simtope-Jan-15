"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginBuildApp = pluginBuildApp;
const runPrerenderEntry_js_1 = require("../../../prerender/runPrerenderEntry.js");
const getOutDirs_js_1 = require("../../shared/getOutDirs.js");
const utils_js_1 = require("../../utils.js");
const context_js_1 = require("../../../prerender/context.js");
const isViteCliCall_js_1 = require("../../shared/isViteCliCall.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const logErrorHint_js_1 = require("../../../runtime/renderPage/logErrorHint.js");
const resolveVikeConfigInternal_js_1 = require("../../shared/resolveVikeConfigInternal.js");
const context_js_2 = require("../../../api/context.js");
const handleAssetsManifest_js_1 = require("./handleAssetsManifest.js");
const isViteServerSide_js_1 = require("../../shared/isViteServerSide.js");
const runPrerenderEntry_js_2 = require("../../../prerender/runPrerenderEntry.js");
const getManifestFilePathRelative_js_1 = require("../../shared/getManifestFilePathRelative.js");
const globalObject = (0, utils_js_1.getGlobalObject)('build/pluginBuildApp.ts', {
    forceExit: false,
});
function pluginBuildApp() {
    let config;
    return [
        {
            name: 'vike:build:pluginBuildApp:pre',
            apply: 'build',
            enforce: 'pre',
            config: {
                order: 'pre',
                handler(_config) {
                    return {
                        builder: {
                            // Can be overridden by another plugin e.g vike-vercel https://github.com/vikejs/vike/pull/2184#issuecomment-2659425195
                            async buildApp(builder) {
                                (0, utils_js_1.assert)(builder.environments.client);
                                (0, utils_js_1.assert)(builder.environments.ssr);
                                await builder.build(builder.environments.client);
                                await builder.build(builder.environments.ssr);
                                if (isPrerenderForceExit()) {
                                    (0, runPrerenderEntry_js_1.runPrerender_forceExit)();
                                    (0, utils_js_1.assert)(false);
                                }
                            },
                        },
                    };
                },
            },
        },
        {
            name: 'vike:build:pluginBuildApp',
            apply: 'build',
            config(config) {
                return {
                    environments: {
                        ssr: {
                            consumer: 'server',
                            build: {
                                outDir: (0, getOutDirs_js_1.resolveOutDir)(config, true),
                                ssr: true,
                            },
                        },
                        client: {
                            consumer: 'client',
                            build: {
                                outDir: (0, getOutDirs_js_1.resolveOutDir)(config, false),
                                copyPublicDir: true,
                                ssr: false,
                            },
                        },
                    },
                };
            },
        },
        {
            name: 'vike:build:pluginBuildApp:autoFullBuild:pre',
            apply: 'build',
            enforce: 'pre',
            async configResolved(config_) {
                config = config_;
                await abortViteBuildSsr();
            },
            // TO-DO/eventually: stop using this writeBundle() hack and, instead, use the buildApp() implementation above.
            // - Could it cause issues if a tool uses the writeBundle() hack together with getVikeConfig() ?
            writeBundle: {
                /* We can't use this because it breaks Vite's logging. TO-DO/eventually: try again with latest Vite version.
                sequential: true,
                order: 'pre',
                */
                async handler(options, bundle) {
                    try {
                        await (0, handleAssetsManifest_js_1.handleAssetsManifest)(config, this.environment, options, bundle);
                        await triggerPrerendering(config, this.environment, bundle);
                    }
                    catch (err) {
                        // We use try-catch also because:
                        // - Vite/Rollup swallows errors thrown inside the writeBundle() hook. (It doesn't swallow errors thrown inside the first writeBundle() hook while building the client-side, but it does swallow errors thrown inside the second writeBundle() while building the server-side triggered after Vike calls Vite's `build()` API.)
                        // - Avoid Rollup prefixing the error with [vike:build:pluginBuildApp], see for example https://github.com/vikejs/vike/issues/472#issuecomment-1276274203
                        console.error(err);
                        (0, logErrorHint_js_1.logErrorHint)(err);
                        process.exit(1);
                    }
                },
            },
        },
        {
            name: 'vike:build:pluginBuildApp:autoFullBuild:post',
            apply: 'build',
            enforce: 'post',
            closeBundle: {
                sequential: true,
                order: 'post',
                handler() {
                    (0, utils_js_1.onSetupBuild)();
                    (0, handleAssetsManifest_js_1.handleAssetsManifest_assertUsageCssTarget)(config, this.environment);
                    /* Let vike:build:pluginBuildApp force exit
                    runPrerender_forceExit()
                    */
                },
            },
        },
    ];
}
async function triggerPrerendering(config, viteEnv, bundle) {
    const vikeConfig = await (0, resolveVikeConfigInternal_js_1.getVikeConfigInternal)();
    if (!(0, isViteServerSide_js_1.isViteServerSide_onlySsrEnv)(config, viteEnv))
        return;
    if (isDisabled(vikeConfig))
        return;
    // Workaround for @vitejs/plugin-legacy
    //  - The legacy plugin triggers its own Rollup build for the client-side.
    //  - The legacy plugin doesn't generate a manifest => we can use that to detect the legacy plugin build.
    //  - Issue & reproduction: https://github.com/vikejs/vike/issues/1154#issuecomment-1965954636
    if (!bundle[(0, getManifestFilePathRelative_js_1.getManifestFilePathRelative)(config.build.manifest)])
        return;
    if (!(0, context_js_1.isPrerenderAutoRunEnabled)(vikeConfig))
        return;
    const configInline = getFullBuildInlineConfig(config);
    const res = await (0, runPrerenderEntry_js_2.runPrerenderFromAutoRun)(configInline);
    globalObject.forceExit = res.forceExit;
    (0, utils_js_1.assert)((0, context_js_1.wasPrerenderRun)());
}
async function abortViteBuildSsr() {
    const vikeConfig = await (0, resolveVikeConfigInternal_js_1.getVikeConfigInternal)();
    if (vikeConfig.config.disableAutoFullBuild !== true && (0, isViteCliCall_js_1.isViteCliCall)() && (0, isViteCliCall_js_1.getViteConfigFromCli)()?.build.ssr) {
        (0, utils_js_1.assertWarning)(false, `The CLI call ${picocolors_1.default.cyan('$ vite build --ssr')} is superfluous since ${picocolors_1.default.cyan('$ vite build')} also builds the server-side. If you want two separate build steps then use https://vike.dev/disableAutoFullBuild or use Vite's ${picocolors_1.default.cyan('build()')} API.`, { onlyOnce: true });
        process.exit(0);
    }
}
function isDisabled(vikeConfig) {
    const { disableAutoFullBuild } = vikeConfig.config;
    if (disableAutoFullBuild === undefined || disableAutoFullBuild === 'prerender') {
        const isUserUsingViteApi = !(0, isViteCliCall_js_1.isViteCliCall)() && !(0, context_js_2.isVikeCliOrApi)();
        return isUserUsingViteApi;
    }
    else {
        return disableAutoFullBuild;
    }
}
function isPrerenderForceExit() {
    return globalObject.forceExit;
}
function getFullBuildInlineConfig(config) {
    const configFromCli = !(0, isViteCliCall_js_1.isViteCliCall)() ? null : (0, isViteCliCall_js_1.getViteConfigFromCli)();
    if (config._viteConfigFromUserEnhanced) {
        return config._viteConfigFromUserEnhanced;
    }
    else {
        return {
            ...configFromCli,
            configFile: configFromCli?.configFile || config.configFile,
            root: config.root,
            build: {
                ...configFromCli?.build,
            },
        };
    }
}
