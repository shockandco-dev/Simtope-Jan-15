"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineOptimizeDeps = determineOptimizeDeps;
const findPageFiles_js_1 = require("../../shared/findPageFiles.js");
const utils_js_1 = require("../../utils.js");
const resolveVikeConfigInternal_js_1 = require("../../shared/resolveVikeConfigInternal.js");
const pluginBuildConfig_js_1 = require("../pluginBuild/pluginBuildConfig.js");
const virtualFileId_js_1 = require("../../../shared/virtualFileId.js");
const getFilePath_js_1 = require("../../shared/getFilePath.js");
const getConfigValueSourcesRelevant_js_1 = require("../pluginVirtualFiles/getConfigValueSourcesRelevant.js");
const debug = (0, utils_js_1.createDebugger)('vike:optimizeDeps');
async function determineOptimizeDeps(config) {
    const vikeConfig = await (0, resolveVikeConfigInternal_js_1.getVikeConfigInternal)();
    const { _pageConfigs: pageConfigs } = vikeConfig;
    const { entriesClient, entriesServer, includeClient, includeServer } = await getPageDeps(config, pageConfigs);
    config.optimizeDeps.include = add(config.optimizeDeps.include, includeClient);
    config.optimizeDeps.entries = add(config.optimizeDeps.entries, entriesClient);
    // Workaround for https://github.com/vitejs/vite-plugin-react/issues/650
    // - The issue was closed as completed with https://github.com/vitejs/vite/pull/20495 but it doesn't fix the issue and the workaround is still needed.
    // - TO-DO/eventually: try removing the workaround and see if the CI fails (at test/@cloudflare_vite-plugin/) â€” maybe the issue will get fixed at some point.
    includeServer.push('react/jsx-dev-runtime');
    for (const envName in config.environments) {
        const env = config.environments[envName];
        if (env.consumer === 'server' && env.optimizeDeps.noDiscovery === false) {
            env.optimizeDeps.include = add(env.optimizeDeps.include, includeServer);
            env.optimizeDeps.entries = add(env.optimizeDeps.entries, entriesServer);
        }
    }
    if (debug.isActivated)
        debug('optimizeDeps', {
            'config.optimizeDeps.entries': config.optimizeDeps.entries,
            'config.optimizeDeps.include': config.optimizeDeps.include,
            'config.optimizeDeps.exclude': config.optimizeDeps.exclude,
            // @ts-ignore Vite doesn't seem to support ssr.optimizeDeps.entries (vite@7.0.6, July 2025)
            'config.ssr.optimizeDeps.entries': config.ssr.optimizeDeps.entries,
            'config.ssr.optimizeDeps.include': config.ssr.optimizeDeps.include,
            'config.ssr.optimizeDeps.exclude': config.ssr.optimizeDeps.exclude,
        });
}
async function getPageDeps(config, pageConfigs) {
    let entriesClient = [];
    let entriesServer = [];
    let includeClient = [];
    let includeServer = [];
    const addEntry = (e, isForClientSide, definedAt) => {
        (0, utils_js_1.assert)(e);
        // optimizeDeps.entries expects filesystem absolute paths
        (0, utils_js_1.assert)((0, utils_js_1.isVirtualFileId)(e) || (0, utils_js_1.isFilePathAbsoluteFilesystem)(e));
        if (isExcluded(e, isForClientSide, definedAt))
            return;
        if (isForClientSide) {
            entriesClient.push(e);
        }
        else {
            entriesServer.push(e);
        }
    };
    const addInclude = (e, isForClientSide, definedAt) => {
        (0, utils_js_1.assert)(e);
        // optimizeDeps.include expects npm packages
        (0, utils_js_1.assert)(!e.startsWith('/'));
        // Shouldn't be a path alias, as path aliases would need to be added to optimizeDeps.entries instead of optimizeDeps.include
        (0, utils_js_1.assertIsImportPathNpmPackage)(e);
        if (isExcluded(e, isForClientSide, definedAt))
            return;
        if (isForClientSide) {
            includeClient.push(e);
        }
        else {
            includeServer.push(e);
        }
    };
    const isExcluded = (e, isForClientSide, definedAt) => {
        const exclude = isForClientSide ? config.optimizeDeps.exclude : config.ssr.optimizeDeps.exclude;
        if (!exclude)
            return false;
        if (definedAt?.importPathAbsolute) {
            const npmPackageName = (0, utils_js_1.getNpmPackageName)(definedAt.importPathAbsolute);
            if (npmPackageName && exclude.includes(npmPackageName))
                return true;
        }
        return exclude.includes(e);
    };
    // V1 design
    {
        ;
        [true, false].forEach((isForClientSide) => {
            pageConfigs.forEach((pageConfig) => {
                Object.entries(pageConfig.configValueSources).forEach(([configName]) => {
                    const runtimeEnv = {
                        isForClientSide,
                        isDev: true,
                        // TO-DO/eventually/remove-server-router: let's eventually remove support for Server Routing
                        isClientRouting: true,
                    };
                    const sourcesRelevant = (0, getConfigValueSourcesRelevant_js_1.getConfigValueSourcesRelevant)(configName, runtimeEnv, pageConfig);
                    sourcesRelevant.forEach((configValueSource) => {
                        if (!configValueSource.valueIsLoadedWithImport && !configValueSource.valueIsFilePath)
                            return;
                        const { definedAt } = configValueSource;
                        if (definedAt.definedBy)
                            return;
                        if (definedAt.filePathAbsoluteUserRootDir !== null) {
                            addEntry(
                            // optimizeDeps.entries expects filesystem absolute paths
                            definedAt.filePathAbsoluteFilesystem, isForClientSide, definedAt);
                        }
                        else {
                            addInclude(
                            // optimizeDeps.include expects npm packages
                            definedAt.importPathAbsolute, isForClientSide, definedAt);
                        }
                    });
                });
            });
        });
    }
    // V0.4 design
    {
        const pageFiles = await (0, findPageFiles_js_1.findPageFiles)(config, ['.page', '.page.client'], true);
        const userRootDir = config.root;
        pageFiles.forEach((filePathAbsoluteUserRootDir) => {
            const entry = (0, getFilePath_js_1.getFilePathResolved)({ filePathAbsoluteUserRootDir, userRootDir });
            const { filePathAbsoluteFilesystem } = entry;
            addEntry(filePathAbsoluteFilesystem, true);
        });
    }
    // Add virtual files.
    // - This doesn't work: Vite's dep optimizer doesn't seem to be able to crawl virtual files.
    //   - Should we make it work? E.g. by creating a temporary file at node_modules/.vike/virtualFiles.js
    //   - Or should we remove it? And make sure getPageDeps() also works for aliased import paths
    //     - If we do, then we need to adjust include/entries (maybe by making include === entries -> will Vite complain?)
    {
        const { hasClientRouting, hasServerRouting, clientEntries } = (0, pluginBuildConfig_js_1.analyzeClientEntries)(pageConfigs, config);
        Object.values(clientEntries).forEach((e) => addEntry(e, true));
        if (hasClientRouting)
            addEntry(virtualFileId_js_1.virtualFileIdGlobalEntryClientCR, true);
        if (hasServerRouting)
            addEntry(virtualFileId_js_1.virtualFileIdGlobalEntryClientSR, true);
    }
    entriesClient = entriesClient;
    entriesServer = entriesServer;
    includeClient = includeClient;
    includeServer = includeServer;
    return {
        entriesClient,
        entriesServer,
        includeClient,
        includeServer,
    };
}
function add(input, listAddendum) {
    const list = !input ? [] : (0, utils_js_1.isArray)(input) ? unique(input) : [input];
    listAddendum.forEach((e) => {
        if (!list.includes(e))
            list.push(e);
    });
    return list;
}
function unique(arr) {
    const arrUnique = Array.from(new Set(arr));
    return arr.length !== arrUnique.length ? arrUnique : arr;
}
