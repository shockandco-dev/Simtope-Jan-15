"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrievePageAssetsProd = retrievePageAssetsProd;
exports.resolveIncludeAssetsImportedByServer = resolveIncludeAssetsImportedByServer;
const utils_js_1 = require("../../utils.js");
const getManifestEntry_js_1 = require("./getManifestEntry.js");
const extractAssetsQuery_js_1 = require("../../../shared/extractAssetsQuery.js");
function retrievePageAssetsProd(assetsManifest, clientDependencies, clientEntries, config) {
    const clientEntriesSrc = clientEntries.map((clientEntry) => getClientEntrySrcProd(clientEntry, assetsManifest));
    const assetUrls = getAssetsUrl(clientDependencies, assetsManifest, config);
    return { clientEntriesSrc, assetUrls };
}
function getClientEntrySrcProd(clientEntry, assetsManifest) {
    const { manifestEntry } = (0, getManifestEntry_js_1.getManifestEntry)(clientEntry, assetsManifest);
    (0, utils_js_1.assert)(manifestEntry.isEntry || manifestEntry.isDynamicEntry || clientEntry.endsWith('.css'), { clientEntry });
    let { file } = manifestEntry;
    (0, utils_js_1.assert)(!file.startsWith('/'));
    return '/' + file;
}
function getAssetsUrl(clientDependencies, assetsManifest, config) {
    const includeAssetsImportedByServer = resolveIncludeAssetsImportedByServer(config);
    let assetUrls = new Set();
    (0, utils_js_1.assert)(assetsManifest);
    const visistedAssets = new Set();
    clientDependencies.forEach(({ id, onlyAssets, eagerlyImported }) => {
        if (eagerlyImported)
            return; // Eagerly imported assets aren't imported with import() and therefore don't create a new Rollup entry and aren't listed in the manifest file
        // TO-DO/next-major-release: remove
        if (includeAssetsImportedByServer &&
            onlyAssets &&
            id.includes('.page.server.') &&
            // We assume that all npm packages have already built their files: bundlers (Rollup, esbuild, tsup, ...) extract the CSS out of JavaScript => we can assume JavaScript to not import any CSS/assets.
            !(0, utils_js_1.isImportPathNpmPackage)(id, {
                // I presume Vite already resolves path aliases when Vite sets the module's id
                cannotBePathAlias: true,
            })) {
            id = (0, extractAssetsQuery_js_1.extractAssetsAddQuery)(id);
        }
        const { manifestKey } = (0, getManifestEntry_js_1.getManifestEntry)(id, assetsManifest);
        collectAssets(manifestKey, assetUrls, visistedAssets, assetsManifest, onlyAssets);
    });
    collectSingleStyle(assetUrls, assetsManifest);
    return Array.from(assetUrls);
}
function collectAssets(manifestKey, assetUrls, visistedAssets, assetsManifest, onlyCollectStaticAssets) {
    if (visistedAssets.has(manifestKey))
        return;
    visistedAssets.add(manifestKey);
    const manifestEntry = assetsManifest[manifestKey];
    (0, utils_js_1.assert)(manifestEntry, { manifestKey });
    const { file } = manifestEntry;
    if (!onlyCollectStaticAssets) {
        assetUrls.add(`/${file}`);
    }
    const { imports = [], assets = [], css = [] } = manifestEntry;
    for (const manifestKey of imports) {
        const importManifestEntry = assetsManifest[manifestKey];
        (0, utils_js_1.assert)(importManifestEntry);
        collectAssets(manifestKey, assetUrls, visistedAssets, assetsManifest, onlyCollectStaticAssets);
    }
    for (const cssAsset of css) {
        assetUrls.add(`/${cssAsset}`);
    }
    for (const asset of assets) {
        assetUrls.add(`/${asset}`);
    }
}
// Support `config.build.cssCodeSplit: false`, see https://github.com/vikejs/vike/issues/644
function collectSingleStyle(assetUrls, assetsManifest) {
    const style = assetsManifest['style.css'];
    if (style && Object.values(assetsManifest).filter((asset) => asset.file.endsWith('.css')).length === 1) {
        assetUrls.add(`/${style.file}`);
    }
}
function resolveIncludeAssetsImportedByServer(config) {
    return config.includeAssetsImportedByServer ?? true;
}
