"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginProdBuildEntry = pluginProdBuildEntry;
exports.set_macro_ASSETS_MANIFEST = set_macro_ASSETS_MANIFEST;
const plugin_1 = require("@brillout/vite-plugin-server-entry/plugin");
const virtualFileId_js_1 = require("../../../shared/virtualFileId.js");
const utils_js_1 = require("../../utils.js");
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const pluginExtractExportNames_js_1 = require("../pluginExtractExportNames.js");
const globalContext_js_1 = require("../../../runtime/globalContext.js");
const getOutDirs_js_1 = require("../../shared/getOutDirs.js");
const getViteConfigRuntime_js_1 = require("../../shared/getViteConfigRuntime.js");
const ASSETS_MANIFEST = '__VITE_ASSETS_MANIFEST__';
function pluginProdBuildEntry() {
    let config;
    return [
        {
            name: 'vike:build:pluginProdBuildEntry',
            apply: 'build',
            enforce: 'post',
            async configResolved(config_) {
                config = config_;
            },
        },
        ...(0, plugin_1.serverProductionEntryPlugin)({
            getServerProductionEntry: () => {
                return getServerProductionEntryCode(config);
            },
            libraryName: 'Vike',
        }),
    ];
}
function getServerProductionEntryCode(config) {
    const importPath = getImportPath(config);
    const buildInfo = {
        versionAtBuildTime: utils_js_1.PROJECT_VERSION,
        usesClientRouter: (0, pluginExtractExportNames_js_1.isUsingClientRouter)(), // TO-DO/next-major-release: remove
        viteConfigRuntime: (0, getViteConfigRuntime_js_1.getViteConfigRuntime)(config),
    };
    (0, globalContext_js_1.assertBuildInfo)(buildInfo);
    // After the old design is removed, let's maybe simplify and move everything into a single virtual module
    const importerCode = [
        `  import { setGlobalContext_prodBuildEntry } from '${importPath}';`,
        `  import * as virtualFileExportsGlobalEntry from '${virtualFileId_js_1.virtualFileIdGlobalEntryServer}';`,
        `  {`,
        // Because of a Rollup bug, we have to assign ASSETS_MANIFEST to a variable before passing it to setGlobalContext_prodBuildEntry()
        // - This workaround doesn't work: https://github.com/vikejs/vike/commit/d5f3a4f7aae5a8bc44192e6cbb2bcb9007be188d
        `    const assetsManifest = ${ASSETS_MANIFEST};`,
        `    const buildInfo = ${JSON.stringify(buildInfo, null, 2)};`,
        '    setGlobalContext_prodBuildEntry({',
        `      virtualFileExportsGlobalEntry,`,
        `      assetsManifest,`,
        `      buildInfo,`,
        '    });',
        `  }`,
        '',
    ].join('\n');
    return importerCode;
}
// Set the value of the ASSETS_MANIFEST constant inside dist/server/entry.js (or dist/server/index.js)
async function set_macro_ASSETS_MANIFEST(assetsJsonFilePath, bundle, outDir) {
    (0, utils_js_1.assert)(outDir);
    const chunkPath = find_ASSETS_MANIFEST(bundle);
    // Some server builds don't contain __VITE_ASSETS_MANIFEST__ such as dist/rsc/ from vike-react-rsc
    if (!chunkPath) {
        const noop = true; // no operation
        return noop;
    }
    (0, utils_js_1.assert)(assetsJsonFilePath);
    const chunkFilePath = node_path_1.default.join(outDir, chunkPath);
    const [assetsJsonString, chunkFileContent] = await Promise.all([
        await promises_1.default.readFile(assetsJsonFilePath, 'utf8'),
        await promises_1.default.readFile(chunkFilePath, 'utf8'),
    ]);
    const serverEntryFileContentPatched = chunkFileContent.replace(ASSETS_MANIFEST, assetsJsonString);
    (0, utils_js_1.assert)(serverEntryFileContentPatched !== chunkFileContent);
    await promises_1.default.writeFile(chunkFilePath, serverEntryFileContentPatched);
    const noop = false;
    return noop;
}
function find_ASSETS_MANIFEST(bundle) {
    let chunkPath;
    for (const filePath in bundle) {
        const chunk = bundle[filePath];
        if ('code' in chunk && chunk.code.includes(ASSETS_MANIFEST)) {
            (0, utils_js_1.assert)(!chunkPath);
            chunkPath = filePath;
        }
    }
    return chunkPath;
}
function getImportPath(config) {
    // We resolve filePathAbsolute even if we don't use it: we use require.resolve() as an assertion that the relative path is correct
    const filePathAbsolute = (0, utils_js_1.requireResolveDistFile)('dist/esm/__internal/index.js');
    if (
    // Let's implement a new config if a user needs the import to be a relative path instead of 'vike/__internal' (AFAIK a relative path is needed only if a framework has npm package 'vike' as direct dependency instead of a peer dependency and if the user of that framework uses pnpm)
    true) {
        return 'vike/__internal';
    }
    else {
        const { outDirServer } = (0, getOutDirs_js_1.getOutDirs)(config, undefined);
        const filePathRelative = node_path_1.default.posix.relative(outDirServer, filePathAbsolute);
        return filePathRelative;
    }
}
