"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginCommon = pluginCommon;
const utils_js_1 = require("../utils.js");
const pluginBuildConfig_js_1 = require("./pluginBuild/pluginBuildConfig.js");
const require_shim_1 = require("@brillout/require-shim");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const node_path_1 = __importDefault(require("node:path"));
const assertResolveAlias_js_1 = require("./pluginCommon/assertResolveAlias.js");
const isViteCliCall_js_1 = require("../shared/isViteCliCall.js");
const context_js_1 = require("../../api/context.js");
const resolveVikeConfigInternal_js_1 = require("../shared/resolveVikeConfigInternal.js");
const prepareViteApiCall_js_1 = require("../../api/prepareViteApiCall.js");
const context_js_2 = require("../../prerender/context.js");
const pluginName = 'vike:pluginCommon';
globalThis.__VIKE__IS_PROCESS_SHARED_WITH_VITE = true;
function pluginCommon(vikeVitePluginOptions) {
    return [
        {
            name: `${pluginName}:pre`,
            enforce: 'pre',
            config: {
                order: 'pre',
                async handler(configFromUser, env) {
                    const isDev = (0, utils_js_1.isDevCheck)(env);
                    const operation = env.command === 'build' ? 'build' : env.isPreview ? 'preview' : 'dev';
                    const rootResolvedEarly = configFromUser.root
                        ? (0, prepareViteApiCall_js_1.normalizeViteRoot)(configFromUser.root)
                        : await (0, prepareViteApiCall_js_1.getViteRoot)(operation);
                    (0, utils_js_1.assert)(rootResolvedEarly);
                    // TO-DO/next-major-release: we can remove setVikeConfigContext() call here since with Vike's CLI it's already called at vike/node/api/prepareViteApiCall.ts
                    (0, resolveVikeConfigInternal_js_1.setVikeConfigContext)({ userRootDir: rootResolvedEarly, isDev, vikeVitePluginOptions });
                    const vikeConfig = await (0, resolveVikeConfigInternal_js_1.getVikeConfigInternal)();
                    return {
                        _isDev: isDev,
                        _rootResolvedEarly: rootResolvedEarly,
                        // TO-DO/next-major-release: remove https://github.com/vikejs/vike/issues/2122
                        configVikePromise: Promise.resolve({
                            prerender: vikeConfig.prerenderContext.isPrerenderingEnabled,
                        }),
                    };
                },
            },
        },
        {
            name: pluginName,
            configResolved(config) {
                (0, prepareViteApiCall_js_1.assertViteRoot)(config._rootResolvedEarly, config);
                assertSingleInstance(config);
                (0, require_shim_1.installRequireShim_setUserRootDir)(config.root);
            },
        },
        {
            name: `${pluginName}:post`,
            enforce: 'post',
            configResolved: {
                order: 'post',
                async handler(config) {
                    /* Also externalize linked dependencies by default?
                     * - Can this be done while the user sets ssr.external to `string[]`? I guess not?
                     *   - If not then it's a problem: it makes the default inconsistent.
                     * - https://vite.dev/config/ssr-options.html#ssr-external
                     * - New setting +transpileLinkedDependencies ?
                    overrideViteDefaultSsrExternal(config)
                    //*/
                    workaroundCI(config);
                    (0, pluginBuildConfig_js_1.assertRollupInput)(config);
                    (0, assertResolveAlias_js_1.assertResolveAlias)(config);
                    assertEsm(config.root);
                    assertVikeCliOrApi(config);
                    temp_supportOldInterface(config);
                    await emitServerEntryOnlyIfNeeded(config);
                },
            },
            config: {
                order: 'post',
                async handler(configFromUser) {
                    let configFromVike = { server: {}, preview: {} };
                    const vikeConfig = await (0, resolveVikeConfigInternal_js_1.getVikeConfigInternal)();
                    if (vikeConfig.config.port !== undefined) {
                        // https://vike.dev/port
                        setDefault('port', vikeConfig.config.port, configFromUser, configFromVike);
                    }
                    else {
                        // Change Vite's default port
                        setDefault('port', 3000, configFromUser, configFromVike);
                    }
                    if (vikeConfig.config.host) {
                        // https://vike.dev/host
                        setDefault('host', vikeConfig.config.host, configFromUser, configFromVike);
                    }
                    else if ((0, utils_js_1.isDocker)()) {
                        // Set `--host` for Docker/Podman
                        setDefault('host', true, configFromUser, configFromVike);
                    }
                    return configFromVike;
                },
            },
        },
    ];
}
// Override Vite's default value without overriding user settings
function setDefault(setting, value, configFromUser, configFromVike) {
    if (configFromUser.server?.[setting] === undefined)
        configFromVike.server[setting] = value;
    if (configFromUser.preview?.[setting] === undefined)
        configFromVike.preview[setting] = value;
}
/*
import { version } from 'vite'
function overrideViteDefaultSsrExternal(config: ResolvedConfig) {
  if (!isVersionOrAbove(version, '5.0.12')) return
  // @ts-ignore Not released yet: https://github.com/vitejs/vite/pull/10939/files#diff-5a3d42620df2c6b17e25f440ffdb67683dee7ef57317674d19f41d5f30502310L5
  config.ssr.external ??= true
}
//*/
// Workaround GitHub Action failing to access the server
function workaroundCI(config) {
    var _a, _b;
    if (process.env.CI) {
        (_a = config.server).host ?? (_a.host = true);
        (_b = config.preview).host ?? (_b.host = true);
    }
}
function assertEsm(userViteRoot) {
    const found = (0, utils_js_1.findPackageJson)(userViteRoot);
    if (!found)
        return;
    const { packageJson, packageJsonPath } = found;
    let dir = node_path_1.default.posix.dirname(packageJsonPath);
    if (dir !== '/') {
        (0, utils_js_1.assert)(!dir.endsWith('/'));
        dir = dir + '/';
    }
    (0, utils_js_1.assert)(dir.endsWith('/'));
    dir = picocolors_1.default.dim(dir);
    (0, utils_js_1.assertWarning)(packageJson.type === 'module', `We recommend setting ${dir}package.json#type to "module", see https://vike.dev/CJS`, { onlyOnce: true });
}
function assertSingleInstance(config) {
    const numberOfInstances = config.plugins.filter((o) => o.name === pluginName).length;
    (0, utils_js_1.assertUsage)(numberOfInstances === 1, `Vike's Vite plugin (${picocolors_1.default.cyan("import vike from 'vike/plugin'")}) is being added ${numberOfInstances} times to the list of Vite plugins. Make sure to add it only once instead.`);
}
function assertVikeCliOrApi(config) {
    if ((0, context_js_1.isVikeCliOrApi)())
        return;
    if ((0, isViteCliCall_js_1.isViteCliCall)()) {
        (0, utils_js_1.assert)(!(0, utils_js_1.isVitest)());
        (0, utils_js_1.assertWarning)(false, `Vite's CLI is deprecated ${picocolors_1.default.underline('https://vike.dev/migration/cli')}`, {
            onlyOnce: true,
        });
        return;
    }
    if ((0, utils_js_1.isVitest)()) {
        (0, utils_js_1.assertWarning)(false, `Unexpected Vitest setup: you seem to be using Vitest together with Vike's Vite plugin but without using Vike's JavaScript API which is unexpected, see ${picocolors_1.default.underline('https://vike.dev/vitest')}`, { onlyOnce: true });
        return;
    }
    if (config.server.middlewareMode) {
        (0, utils_js_1.assertWarning)(false, `${picocolors_1.default.cyan('vite.createServer()')} is deprecated ${picocolors_1.default.underline('https://vike.dev/migration/cli#api')}`, {
            onlyOnce: true,
        });
        return;
    }
    (0, utils_js_1.assertWarning)(false, `Vite's JavaScript API is deprecated ${picocolors_1.default.underline('https://vike.dev/migration/cli#api')}`, {
        onlyOnce: true,
    });
}
// TO-DO/next-major-release: remove https://github.com/vikejs/vike/issues/2122
function temp_supportOldInterface(config) {
    if (!('vitePluginSsr' in config))
        return;
    (0, utils_js_1.assert)((0, utils_js_1.isObject)(config.vitePluginSsr));
    if ((0, utils_js_1.hasProp)(config.vitePluginSsr, 'prerender', 'object')) {
        (0, utils_js_1.assert)((0, utils_js_1.hasProp)(config.vitePluginSsr.prerender, 'disableAutoRun', 'boolean'));
        if (config.vitePluginSsr.prerender.disableAutoRun) {
            (0, context_js_2.temp_disablePrerenderAutoRun)();
        }
        return;
    }
    if ((0, utils_js_1.hasProp)(config.vitePluginSsr, 'disableAutoFullBuild')) {
        if (config.vitePluginSsr.disableAutoFullBuild) {
            (0, utils_js_1.assert)(config.vitePluginSsr.disableAutoFullBuild === 'prerender');
            (0, context_js_2.temp_disablePrerenderAutoRun)();
        }
        return;
    }
    (0, utils_js_1.assert)(false);
}
// Only emit dist/server/entry.mjs if necessary
async function emitServerEntryOnlyIfNeeded(config) {
    const vikeConfig = await (0, resolveVikeConfigInternal_js_1.getVikeConfigInternal)();
    if (config.vitePluginServerEntry?.inject && !vikeConfig.prerenderContext.isPrerenderingEnabled) {
        config.vitePluginServerEntry.disableServerEntryEmit = true;
    }
}
