"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGlobalContextSyncErrMsg = void 0;
exports.createGlobalContextShared = createGlobalContextShared;
const utils_js_1 = require("./utils.js");
const parseVirtualFileExportsGlobalEntry_js_1 = require("./getPageFiles/parseVirtualFileExportsGlobalEntry.js");
const resolveVikeConfigPublic_js_1 = require("./page-configs/resolveVikeConfigPublic.js");
const execHook_js_1 = require("./hooks/execHook.js");
const prepareGlobalContextForPublicUsage_js_1 = require("./prepareGlobalContextForPublicUsage.js");
const getHook_js_1 = require("./hooks/getHook.js");
const getGlobalContextSyncErrMsg = "The global context isn't set yet, call getGlobalContextSync() later or use getGlobalContext() instead.";
exports.getGlobalContextSyncErrMsg = getGlobalContextSyncErrMsg;
// TO-DO/eventually use flat globalContext â€” like flat pageContext
async function createGlobalContextShared(virtualFileExportsGlobalEntry, globalObject, addGlobalContext, 
// TO-DO/next-major-release: we'll be able to remove addGlobalContextTmp after loadPageRoutes() is sync (it will be sync after we remove the old design)
addGlobalContextTmp, addGlobalContextAsync) {
    const { previousCreateGlobalContextPromise } = globalObject;
    const { promise, resolve } = (0, utils_js_1.genPromise)({
        // Avoid this Cloudflare Worker error:
        // ```console
        // Error: Disallowed operation called within global scope. Asynchronous I/O (ex: fetch() or connect()), setting a timeout, and generating random values are not allowed within global scope. To fix this error, perform this operation within a handler.
        // ```
        timeout: null,
    });
    globalObject.previousCreateGlobalContextPromise = promise;
    if (previousCreateGlobalContextPromise) {
        (0, utils_js_1.assert)(globalObject.globalContext);
        await previousCreateGlobalContextPromise;
    }
    const globalContext = createGlobalContextBase(virtualFileExportsGlobalEntry);
    let isNewGlobalContext;
    if (!globalObject.globalContext) {
        // We set globalObject.globalContext early and before any async operations, so that getGlobalContextSync() can be used early.
        // - Required by vike-vercel
        globalObject.globalContext = globalContext;
        isNewGlobalContext = false;
    }
    else {
        isNewGlobalContext = true;
    }
    if (addGlobalContext &&
        // TO-DO/next-major-release: remove
        globalContext._pageConfigs.length > 0) {
        const globalContextAdded = addGlobalContext?.(globalContext);
        (0, utils_js_1.objectAssign)(globalContext, globalContextAdded);
    }
    else {
        const globalContextAdded = await addGlobalContextTmp?.(globalContext);
        (0, utils_js_1.objectAssign)(globalContext, globalContextAdded);
    }
    {
        const globalContextAddedAsync = await addGlobalContextAsync?.(globalContext);
        (0, utils_js_1.objectAssign)(globalContext, globalContextAddedAsync);
    }
    const onCreateGlobalContextHooks = (0, getHook_js_1.getHookFromPageConfigGlobalCumulative)(globalContext._pageConfigGlobal, 'onCreateGlobalContext');
    let hooksCalled = false;
    if (!hooksAreEqual(globalObject.onCreateGlobalContextHooks ?? [], onCreateGlobalContextHooks)) {
        globalObject.onCreateGlobalContextHooks = onCreateGlobalContextHooks;
        await (0, execHook_js_1.execHookGlobal)('onCreateGlobalContext', globalContext._pageConfigGlobal, null, globalContext, prepareGlobalContextForPublicUsage_js_1.prepareGlobalContextForPublicUsage);
        hooksCalled = true;
    }
    if (isNewGlobalContext) {
        // Singleton: ensure all `globalContext` user-land references are preserved & updated.
        if (hooksCalled) {
            (0, utils_js_1.objectReplace)(globalObject.globalContext, globalContext);
        }
        else {
            // We don't use objectReplace() in order to keep user-land properties.
            (0, utils_js_1.objectAssign)(globalObject.globalContext, globalContext, true);
        }
    }
    resolve();
    return globalObject.globalContext;
}
function createGlobalContextBase(virtualFileExportsGlobalEntry) {
    const { pageFilesAll, allPageIds, pageConfigs, pageConfigGlobal, vikeConfigPublicGlobal, vikeConfigPublicPagesEager, } = getConfigsAll(virtualFileExportsGlobalEntry);
    const globalContext = {
        /**
         * Useful for distinguishing `globalContext` from other objects and narrowing down TypeScript unions.
         *
         * https://vike.dev/globalContext#typescript
         */
        isGlobalContext: true,
        _isOriginalObject: true,
        _virtualFileExportsGlobalEntry: virtualFileExportsGlobalEntry,
        _pageFilesAll: pageFilesAll,
        _pageConfigs: pageConfigs,
        _pageConfigGlobal: pageConfigGlobal,
        _allPageIds: allPageIds,
        _vikeConfigPublicGlobal: vikeConfigPublicGlobal,
        config: vikeConfigPublicGlobal.config,
        pages: vikeConfigPublicPagesEager,
    };
    (0, utils_js_1.changeEnumerable)(globalContext, '_isOriginalObject', false);
    return globalContext;
}
function getConfigsAll(virtualFileExportsGlobalEntry) {
    const { pageFilesAll, pageConfigs, pageConfigGlobal } = (0, parseVirtualFileExportsGlobalEntry_js_1.parseVirtualFileExportsGlobalEntry)(virtualFileExportsGlobalEntry);
    const allPageIds = getAllPageIds(pageFilesAll, pageConfigs);
    const vikeConfigPublicGlobal = (0, resolveVikeConfigPublic_js_1.resolveVikeConfigPublicGlobal)({
        pageConfigGlobalValues: pageConfigGlobal.configValues,
    });
    const vikeConfigPublicPagesEager = Object.fromEntries(pageConfigs.map((pageConfig) => {
        return (0, resolveVikeConfigPublic_js_1.resolveVikeConfigPublicPageEagerLoaded)(pageConfigGlobal.configValues, pageConfig, pageConfig.configValues);
    }));
    return {
        pageFilesAll,
        allPageIds,
        pageConfigs,
        pageConfigGlobal,
        vikeConfigPublicGlobal,
        vikeConfigPublicPagesEager,
    };
}
function getAllPageIds(pageFilesAll, pageConfigs) {
    const fileIds = pageFilesAll.filter(({ isDefaultPageFile }) => !isDefaultPageFile).map(({ pageId }) => pageId);
    const allPageIds = (0, utils_js_1.unique)(fileIds);
    const allPageIds2 = pageConfigs.map((p) => p.pageId);
    return [...allPageIds, ...allPageIds2];
}
function hooksAreEqual(hooks1, hooks2) {
    const hooksFn1 = hooks1.map((hook) => hook.hookFn);
    const hooksFn2 = hooks2.map((hook) => hook.hookFn);
    return (hooksFn1.every((hook) => hooksFn2.includes(hook)) &&
        //
        hooksFn2.every((hook) => hooksFn1.includes(hook)));
}
