"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderPage = renderPage;
exports.renderPage_addAsyncHookwrapper = renderPage_addAsyncHookwrapper;
const renderPageAfterRoute_js_1 = require("./renderPage/renderPageAfterRoute.js");
const createPageContextServerSide_js_1 = require("./renderPage/createPageContextServerSide.js");
const index_js_1 = require("../../shared/route/index.js");
const utils_js_1 = require("./utils.js");
const abort_js_1 = require("../../shared/route/abort.js");
const globalContext_js_1 = require("./globalContext.js");
const handlePageContextRequestUrl_js_1 = require("./renderPage/handlePageContextRequestUrl.js");
const createHttpResponse_js_1 = require("./renderPage/createHttpResponse.js");
const loggerRuntime_js_1 = require("./loggerRuntime.js");
const isNewError_js_1 = require("./renderPage/isNewError.js");
const assertArguments_js_1 = require("./renderPage/assertArguments.js");
const index_js_2 = require("./renderPage/log404/index.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const serializeContext_js_1 = require("./html/serializeContext.js");
const error_page_js_1 = require("../../shared/error-page.js");
const handleErrorWithoutErrorPage_js_1 = require("./renderPage/handleErrorWithoutErrorPage.js");
const loadPageConfigsLazyServerSide_js_1 = require("./renderPage/loadPageConfigsLazyServerSide.js");
const resolveRedirects_js_1 = require("./renderPage/resolveRedirects.js");
const getVikeConfigError_js_1 = require("../shared/getVikeConfigError.js");
const globalObject = (0, utils_js_1.getGlobalObject)('runtime/renderPage.ts', {
    httpRequestsCount: 0,
    asyncHookWrapper: getFallbackAsyncHookWrapper(),
});
// `renderPage()` calls `renderPageNominal()` while ensuring that errors are `console.error(err)` instead of `throw err`, so that Vike never triggers a server shut down. (Throwing an error in an Express.js middleware shuts down the whole Express.js server.)
async function renderPage(pageContextInit) {
    (0, assertArguments_js_1.assertArguments)(...arguments);
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContextInit, 'urlOriginal', 'string')); // assertUsage() already implemented at assertArguments()
    assertIsUrl(pageContextInit.urlOriginal);
    (0, utils_js_1.onSetupRuntime)();
    const pageContextSkipRequest = getPageContextSkipRequest(pageContextInit);
    if (pageContextSkipRequest)
        return pageContextSkipRequest;
    const httpRequestId = getRequestId();
    const urlOriginalPretty = (0, utils_js_1.getUrlPretty)(pageContextInit.urlOriginal);
    logHttpRequest(urlOriginalPretty, httpRequestId);
    const { pageContextReturn } = await globalObject.asyncHookWrapper(httpRequestId, () => renderPagePrepare(pageContextInit, httpRequestId));
    logHttpResponse(urlOriginalPretty, httpRequestId, pageContextReturn);
    (0, utils_js_1.checkType)(pageContextReturn);
    (0, utils_js_1.assert)(pageContextReturn.httpResponse);
    return pageContextReturn;
}
// Add node:async_hooks wrapper
function renderPage_addAsyncHookwrapper(wrapper) {
    globalObject.asyncHookWrapper = wrapper;
}
// Fallback wrapper if node:async_hooks isn't available
function getFallbackAsyncHookWrapper() {
    return async (_httpRequestId, ret) => ({
        pageContextReturn: await ret(),
    });
}
async function renderPagePrepare(pageContextInit, httpRequestId) {
    // Invalid config
    {
        const vikeConfigError = (0, getVikeConfigError_js_1.getVikeConfigError)();
        if (vikeConfigError) {
            return getPageContextInvalidVikeConfig(vikeConfigError.err, pageContextInit, httpRequestId);
        }
    }
    // Prepare context
    try {
        await (0, globalContext_js_1.initGlobalContext_renderPage)();
    }
    catch (err) {
        // Errors are expected since assertUsage() is used in initGlobalContext_renderPage() such as:
        // ```bash
        // Re-build your app (you're using 1.2.3 but your app was built with 1.2.2)
        // ```
        // initGlobalContext_renderPage() doesn't call any user hook => err isn't thrown from user code.
        (0, utils_js_1.assert)(!(0, abort_js_1.isAbortError)(err));
        (0, loggerRuntime_js_1.logRuntimeError)(err, httpRequestId);
        const pageContextWithError = getPageContextHttpResponseErrorWithoutGlobalContext(err, pageContextInit);
        return pageContextWithError;
    }
    {
        const vikeConfigError = (0, getVikeConfigError_js_1.getVikeConfigError)();
        if (vikeConfigError) {
            return getPageContextInvalidVikeConfig(vikeConfigError.err, pageContextInit, httpRequestId);
        }
        else {
            // `globalContext` now contains the entire Vike config and getVikeConfig() isn't called anymore for this request.
        }
    }
    const { globalContext } = await (0, globalContext_js_1.getGlobalContextServerInternal)();
    const pageContextBegin = getPageContextBegin(pageContextInit, globalContext, httpRequestId);
    // Check Base URL
    {
        const pageContextHttpResponse = await checkBaseUrl(pageContextBegin, globalContext);
        if (pageContextHttpResponse)
            return pageContextHttpResponse;
    }
    // Normalize URL
    {
        const pageContextHttpResponse = await normalizeUrl(pageContextBegin, globalContext, httpRequestId);
        if (pageContextHttpResponse)
            return pageContextHttpResponse;
    }
    // Permanent redirects (HTTP status code `301`)
    {
        const pageContextHttpResponse = await getPermanentRedirect(pageContextBegin, globalContext, httpRequestId);
        if (pageContextHttpResponse)
            return pageContextHttpResponse;
    }
    return await renderPageAlreadyPrepared(pageContextBegin, globalContext, httpRequestId, []);
}
async function renderPageAlreadyPrepared(pageContextBegin, globalContext, httpRequestId, pageContextsFromRewrite) {
    const pageContextNominalPageBegin = forkPageContext(pageContextBegin);
    (0, abort_js_1.assertNoInfiniteAbortLoop)(pageContextsFromRewrite.length, 
    // There doesn't seem to be a way to count the number of HTTP redirects (vike don't have access to the HTTP request headers/cookies)
    // https://stackoverflow.com/questions/9683007/detect-infinite-http-redirect-loop-on-server-side
    0);
    let pageContextNominalPageSuccess;
    const pageContextFromAllRewrites = (0, abort_js_1.getPageContextFromAllRewrites)(pageContextsFromRewrite);
    // This is where pageContext._urlRewrite is set
    (0, utils_js_1.assert)(pageContextFromAllRewrites._urlRewrite === null || typeof pageContextFromAllRewrites._urlRewrite === 'string');
    (0, utils_js_1.objectAssign)(pageContextNominalPageBegin, pageContextFromAllRewrites);
    let errNominalPage;
    {
        try {
            pageContextNominalPageSuccess = await renderPageNominal(pageContextNominalPageBegin);
        }
        catch (err) {
            errNominalPage = err;
            (0, utils_js_1.assert)(errNominalPage);
            (0, loggerRuntime_js_1.logRuntimeError)(errNominalPage, httpRequestId);
        }
        if (!errNominalPage) {
            (0, utils_js_1.assert)(pageContextNominalPageSuccess === pageContextNominalPageBegin);
        }
    }
    // Log upon 404
    if (pageContextNominalPageSuccess &&
        'is404' in pageContextNominalPageSuccess &&
        pageContextNominalPageSuccess.is404 === true) {
        await (0, index_js_2.log404)(pageContextNominalPageSuccess);
    }
    if (errNominalPage === undefined) {
        (0, utils_js_1.assert)(pageContextNominalPageSuccess);
        return pageContextNominalPageSuccess;
    }
    else {
        (0, utils_js_1.assert)(errNominalPage);
        (0, utils_js_1.assert)(pageContextNominalPageSuccess === undefined);
        return await renderPageOnError(errNominalPage, pageContextBegin, pageContextNominalPageBegin, globalContext, httpRequestId, pageContextsFromRewrite);
    }
}
// When the normal page threw an error
// - Can be a URL rewrite upon `throw render('/some-url')`
// - Can be rendering the error page
// - Can be rendering Vike's generic error page (if no error page is defined, or if the error page throws an error)
async function renderPageOnError(errNominalPage, pageContextBegin, pageContextNominalPageBegin, globalContext, httpRequestId, pageContextsFromRewrite) {
    (0, utils_js_1.assert)(pageContextNominalPageBegin);
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContextNominalPageBegin, 'urlOriginal', 'string'));
    const pageContextErrorPageInit = await getPageContextErrorPageInit(pageContextBegin, errNominalPage);
    // Handle `throw redirect()` and `throw render()` while rendering nominal page
    if ((0, abort_js_1.isAbortError)(errNominalPage)) {
        const handled = await handleAbortError(errNominalPage, pageContextsFromRewrite, pageContextBegin, pageContextNominalPageBegin, httpRequestId, pageContextErrorPageInit, globalContext);
        if (handled.pageContextReturn) {
            // - throw redirect()
            // - throw render(url)
            // - throw render(abortStatusCode) if .pageContext.json request
            return handled.pageContextReturn;
        }
        else {
            // - throw render(abortStatusCode) if not .pageContext.json request
        }
        Object.assign(pageContextErrorPageInit, handled.pageContextAbort);
    }
    {
        const errorPageId = (0, error_page_js_1.getErrorPageId)(globalContext._pageFilesAll, globalContext._pageConfigs);
        if (!errorPageId) {
            (0, utils_js_1.objectAssign)(pageContextErrorPageInit, { pageId: null });
            return (0, handleErrorWithoutErrorPage_js_1.handleErrorWithoutErrorPage)(pageContextErrorPageInit);
        }
        (0, utils_js_1.objectAssign)(pageContextErrorPageInit, { pageId: errorPageId });
    }
    let pageContextErrorPage;
    try {
        pageContextErrorPage = await (0, renderPageAfterRoute_js_1.renderPageAfterRoute)(pageContextErrorPageInit);
    }
    catch (errErrorPage) {
        // Handle `throw redirect()` and `throw render()` while rendering error page
        if ((0, abort_js_1.isAbortError)(errErrorPage)) {
            const handled = await handleAbortError(errErrorPage, pageContextsFromRewrite, pageContextBegin, pageContextNominalPageBegin, httpRequestId, pageContextErrorPageInit, globalContext);
            // throw render(abortStatusCode)
            if (!handled.pageContextReturn) {
                const pageContextAbort = errErrorPage._pageContextAbort;
                (0, utils_js_1.assertWarning)(false, `Failed to render error page because ${picocolors_1.default.cyan(pageContextAbort._abortCall)} was called: make sure ${picocolors_1.default.cyan(pageContextAbort._abortCaller)} doesn't occur while the error page is being rendered.`, { onlyOnce: false });
                const pageContextHttpWithError = getPageContextHttpResponseError(errNominalPage, pageContextBegin);
                return pageContextHttpWithError;
            }
            // `throw redirect()` / `throw render(url)`
            return handled.pageContextReturn;
        }
        if ((0, isNewError_js_1.isNewError)(errErrorPage, errNominalPage)) {
            (0, loggerRuntime_js_1.logRuntimeError)(errErrorPage, httpRequestId);
        }
        const pageContextWithError = getPageContextHttpResponseError(errNominalPage, pageContextBegin);
        return pageContextWithError;
    }
    return pageContextErrorPage;
}
function logHttpRequest(urlOriginal, httpRequestId) {
    (0, loggerRuntime_js_1.logRuntimeInfo)?.(getRequestInfoMessage(urlOriginal), httpRequestId, 'info');
}
function getRequestInfoMessage(urlOriginal) {
    return `HTTP request: ${prettyUrl(urlOriginal)}`;
}
function logHttpResponse(urlOriginalPretty, httpRequestId, pageContextReturn) {
    const statusCode = pageContextReturn.httpResponse?.statusCode ?? null;
    let msg;
    let isNominal;
    {
        const { errorWhileRendering } = pageContextReturn;
        const isSkipped = statusCode === null && !errorWhileRendering;
        if (isSkipped) {
            // - URL doesn't include Base URL
            //   - Can we abort earlier so that `logHttpResponse()` and `logHttpRequest()` aren't even called?
            // - Error loading a Vike config file
            //   - We should show `HTTP response ${urlOriginalPretty} ERR` instead.
            //   - Maybe we can/should make the error available at pageContext.errorWhileRendering
            (0, utils_js_1.assert)(errorWhileRendering === null || errorWhileRendering === undefined);
            msg = `HTTP response ${prettyUrl(urlOriginalPretty)} ${picocolors_1.default.dim('null')}`;
            // Erroneous value (it should sometimes be `false`) but it's fine as it doesn't seem to have much of an impact.
            isNominal = true;
        }
        else {
            const isSuccess = statusCode !== null && statusCode >= 200 && statusCode <= 399;
            isNominal = isSuccess || statusCode === 404;
            const color = (s) => picocolors_1.default.bold(isSuccess ? picocolors_1.default.green(String(s)) : picocolors_1.default.red(String(s)));
            const isRedirect = statusCode && 300 <= statusCode && statusCode <= 399;
            const type = isRedirect ? 'redirect' : 'response';
            if (isRedirect) {
                (0, utils_js_1.assert)(pageContextReturn.httpResponse);
                const headerRedirect = pageContextReturn.httpResponse.headers
                    .slice()
                    .reverse()
                    .find((header) => header[0] === 'Location');
                (0, utils_js_1.assert)(headerRedirect);
                const urlRedirect = headerRedirect[1];
                urlOriginalPretty = urlRedirect;
            }
            msg = `HTTP ${type} ${prettyUrl(urlOriginalPretty)} ${color(statusCode ?? 'ERR')}`;
        }
    }
    (0, loggerRuntime_js_1.logRuntimeInfo)?.(msg, httpRequestId, isNominal ? 'info' : 'error');
}
function prettyUrl(url) {
    try {
        url = decodeURI(url);
    }
    catch {
        // https://github.com/vikejs/vike/pull/2367#issuecomment-2800967564
    }
    return picocolors_1.default.bold(url);
}
function getPageContextHttpResponseError(err, pageContextBegin) {
    const pageContextWithError = forkPageContext(pageContextBegin);
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponseError)(pageContextBegin);
    (0, utils_js_1.objectAssign)(pageContextWithError, {
        httpResponse,
        errorWhileRendering: err,
    });
    return pageContextWithError;
}
function getPageContextHttpResponseErrorWithoutGlobalContext(err, pageContextInit) {
    const pageContextWithError = (0, createPageContextServerSide_js_1.createPageContextServerSideWithoutGlobalContext)(pageContextInit);
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponseErrorWithoutGlobalContext)();
    (0, utils_js_1.objectAssign)(pageContextWithError, {
        httpResponse,
        errorWhileRendering: err,
    });
    return pageContextWithError;
}
async function renderPageNominal(pageContext) {
    (0, utils_js_1.objectAssign)(pageContext, { errorWhileRendering: null });
    // Route
    {
        const pageContextFromRoute = await (0, index_js_1.route)(pageContext);
        (0, utils_js_1.objectAssign)(pageContext, pageContextFromRoute);
        (0, utils_js_1.objectAssign)(pageContext, { is404: pageContext.pageId ? null : true });
        if (pageContext.pageId === null) {
            const errorPageId = (0, error_page_js_1.getErrorPageId)(pageContext._globalContext._pageFilesAll, pageContext._globalContext._pageConfigs);
            if (!errorPageId) {
                (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContext, 'pageId', 'null'));
                return (0, handleErrorWithoutErrorPage_js_1.handleErrorWithoutErrorPage)(pageContext);
            }
            (0, utils_js_1.objectAssign)(pageContext, { pageId: errorPageId });
        }
    }
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContext, 'pageId', 'string'));
    (0, utils_js_1.assert)(pageContext.errorWhileRendering === null);
    // Render
    const pageContextAfterRender = await (0, renderPageAfterRoute_js_1.renderPageAfterRoute)(pageContext);
    (0, utils_js_1.assert)(pageContext === pageContextAfterRender);
    return pageContextAfterRender;
}
async function getPageContextErrorPageInit(pageContextBegin, errNominalPage) {
    const pageContext = forkPageContext(pageContextBegin);
    (0, utils_js_1.assert)(errNominalPage);
    (0, utils_js_1.objectAssign)(pageContext, {
        is404: false,
        errorWhileRendering: errNominalPage,
        routeParams: {},
    });
    (0, utils_js_1.assert)(pageContext.errorWhileRendering);
    return pageContext;
}
function getPageContextBegin(pageContextInit, globalContext, httpRequestId) {
    const { isClientSideNavigation, _urlHandler, _isPageContextJsonRequest } = handlePageContextUrl(pageContextInit.urlOriginal);
    const pageContextBegin = (0, createPageContextServerSide_js_1.createPageContextServerSide)(pageContextInit, globalContext, {
        isPrerendering: false,
        ssr: {
            urlHandler: _urlHandler,
            isClientSideNavigation,
        },
    });
    (0, utils_js_1.objectAssign)(pageContextBegin, { _httpRequestId: httpRequestId, _isPageContextJsonRequest });
    return pageContextBegin;
}
function handlePageContextUrl(urlOriginal) {
    const { isPageContextJsonRequest } = (0, handlePageContextRequestUrl_js_1.handlePageContextRequestUrl)(urlOriginal);
    return {
        isClientSideNavigation: !!isPageContextJsonRequest,
        _isPageContextJsonRequest: isPageContextJsonRequest,
        _urlHandler: (url) => (0, handlePageContextRequestUrl_js_1.handlePageContextRequestUrl)(url).urlWithoutPageContextRequestSuffix,
    };
}
function getRequestId() {
    const httpRequestId = ++globalObject.httpRequestsCount;
    (0, utils_js_1.assert)(httpRequestId >= 1);
    return httpRequestId;
}
function assertIsUrl(urlOriginal) {
    (0, utils_js_1.assertUsage)((0, utils_js_1.isUrl)(urlOriginal), `${picocolors_1.default.code('renderPage(pageContextInit)')} (https://vike.dev/renderPage) called with ${picocolors_1.default.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which isn't a valid URL.`);
}
function assertIsNotViteRequest(urlPathname, urlOriginal) {
    const isViteRequest = urlPathname.startsWith('/@vite/client') || urlPathname.startsWith('/@fs/') || urlPathname.startsWith('/__vite_ping');
    if (!isViteRequest)
        return;
    (0, utils_js_1.assertUsage)(false, `${picocolors_1.default.code('renderPage(pageContextInit)')} called with ${picocolors_1.default.code(`pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}`)} which is unexpected because the URL ${picocolors_1.default.bold(urlOriginal)} should have already been handled by the development middleware: make sure the ${picocolors_1.default.cyan('createDevMiddleware()')} middleware is executed *before* the ${picocolors_1.default.cyan('renderPage()')} middleware, see ${picocolors_1.default.underline('https://vike.dev/renderPage')}`);
}
async function normalizeUrl(pageContextBegin, globalContext, httpRequestId) {
    const pageContext = forkPageContext(pageContextBegin);
    const { trailingSlash, disableUrlNormalization } = globalContext.config;
    if (disableUrlNormalization)
        return null;
    const { urlOriginal } = pageContext;
    const { isPageContextJsonRequest } = (0, handlePageContextRequestUrl_js_1.handlePageContextRequestUrl)(urlOriginal);
    if (isPageContextJsonRequest)
        return null;
    const urlNormalized = (0, utils_js_1.normalizeUrlPathname)(urlOriginal, trailingSlash ?? false, globalContext.baseServer);
    if (!urlNormalized)
        return null;
    (0, loggerRuntime_js_1.logRuntimeInfo)?.(`URL normalized from ${picocolors_1.default.cyan(urlOriginal)} to ${picocolors_1.default.cyan(urlNormalized)} (https://vike.dev/url-normalization)`, httpRequestId, 'info');
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponseRedirect)({ url: urlNormalized, statusCode: 301 }, pageContext);
    (0, utils_js_1.objectAssign)(pageContext, { httpResponse });
    return pageContext;
}
async function getPermanentRedirect(pageContextBegin, globalContext, httpRequestId) {
    const pageContext = forkPageContext(pageContextBegin);
    const urlWithoutBase = (0, utils_js_1.removeBaseServer)(pageContext.urlOriginal, globalContext.baseServer);
    let origin = null;
    let urlTargetExternal = null;
    let urlTarget = (0, utils_js_1.modifyUrlPathname)(urlWithoutBase, (urlPathname) => {
        const urlTarget = (0, resolveRedirects_js_1.resolveRedirects)(globalContext.config.redirects ?? [], urlPathname);
        if (urlTarget === null)
            return null;
        if (!(0, utils_js_1.isUrl)(urlTarget)) {
            // E.g. `urlTarget === 'mailto:some@example.com'`
            (0, utils_js_1.assert)((0, utils_js_1.isUri)(urlTarget));
            urlTargetExternal = urlTarget;
            return null;
        }
        const { urlModified, origin: origin_ } = (0, utils_js_1.removeUrlOrigin)(urlTarget);
        origin = origin_;
        return urlModified;
    });
    if (urlTargetExternal) {
        urlTarget = urlTargetExternal;
    }
    else {
        let originChanged = false;
        if (origin) {
            const urlModified = (0, utils_js_1.setUrlOrigin)(urlTarget, origin);
            if (urlModified !== false) {
                originChanged = true;
                urlTarget = urlModified;
            }
        }
        if (normalize(urlTarget) === normalize(urlWithoutBase))
            return null;
        if (!originChanged)
            urlTarget = (0, utils_js_1.prependBase)(urlTarget, globalContext.baseServer);
        (0, utils_js_1.assert)(urlTarget !== pageContext.urlOriginal);
    }
    (0, loggerRuntime_js_1.logRuntimeInfo)?.(`Permanent redirection defined by config.redirects (https://vike.dev/redirects)`, httpRequestId, 'info');
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponseRedirect)({ url: urlTarget, statusCode: 301 }, pageContext);
    (0, utils_js_1.objectAssign)(pageContext, { httpResponse });
    return pageContext;
}
function normalize(url) {
    return url || '/';
}
async function handleAbortError(errAbort, pageContextsFromRewrite, pageContextBegin, 
// handleAbortError() creates a new pageContext object and we don't merge pageContextNominalPageBegin to it: we only use some pageContextNominalPageBegin information.
pageContextNominalPageBegin, httpRequestId, pageContextErrorPageInit, globalContext) {
    (0, abort_js_1.logAbortErrorHandled)(errAbort, globalContext._isProduction, pageContextNominalPageBegin);
    const pageContextAbort = errAbort._pageContextAbort;
    let pageContextSerialized;
    if (pageContextNominalPageBegin.isClientSideNavigation) {
        if (pageContextAbort.abortStatusCode) {
            const errorPageId = (0, error_page_js_1.getErrorPageId)(globalContext._pageFilesAll, globalContext._pageConfigs);
            const abortCall = pageContextAbort._abortCall;
            (0, utils_js_1.assert)(abortCall);
            (0, utils_js_1.assertUsage)(errorPageId, `You called ${picocolors_1.default.cyan(abortCall)} but you didn't define an error page, make sure to define one https://vike.dev/error-page`);
            const pageContext = forkPageContext(pageContextBegin);
            (0, utils_js_1.objectAssign)(pageContext, { pageId: errorPageId });
            (0, utils_js_1.objectAssign)(pageContext, pageContextAbort);
            (0, utils_js_1.objectAssign)(pageContext, pageContextErrorPageInit, true);
            (0, utils_js_1.updateType)(pageContext, await (0, loadPageConfigsLazyServerSide_js_1.loadPageConfigsLazyServerSide)(pageContext));
            // We include pageContextInit: we don't only serialize pageContextAbort because the error page may need to access pageContextInit
            pageContextSerialized = (0, serializeContext_js_1.getPageContextClientSerialized)(pageContext, false);
        }
        else {
            pageContextSerialized = (0, serializeContext_js_1.getPageContextClientSerializedAbort)(pageContextAbort, false);
        }
        const httpResponse = await (0, createHttpResponse_js_1.createHttpResponsePageContextJson)(pageContextSerialized);
        const pageContextReturn = { httpResponse };
        return { pageContextReturn };
    }
    if (pageContextAbort._urlRewrite) {
        const pageContextReturn = await renderPageAlreadyPrepared(pageContextBegin, globalContext, httpRequestId, [
            ...pageContextsFromRewrite,
            pageContextAbort,
        ]);
        Object.assign(pageContextReturn, pageContextAbort);
        return { pageContextReturn };
    }
    if (pageContextAbort._urlRedirect) {
        const pageContextReturn = forkPageContext(pageContextBegin);
        (0, utils_js_1.objectAssign)(pageContextReturn, pageContextAbort);
        const httpResponse = (0, createHttpResponse_js_1.createHttpResponseRedirect)(pageContextAbort._urlRedirect, pageContextBegin);
        (0, utils_js_1.objectAssign)(pageContextReturn, { httpResponse });
        return { pageContextReturn };
    }
    (0, utils_js_1.assert)(pageContextAbort.abortStatusCode);
    return { pageContextAbort };
}
async function checkBaseUrl(pageContextBegin, globalContext) {
    const pageContext = forkPageContext(pageContextBegin);
    const { baseServer } = globalContext;
    const { urlOriginal } = pageContext;
    const { isBaseMissing } = (0, utils_js_1.parseUrl)(urlOriginal, baseServer);
    if (!isBaseMissing)
        return;
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponseBaseIsMissing)(urlOriginal, baseServer);
    (0, utils_js_1.objectAssign)(pageContext, {
        httpResponse,
        isBaseMissing: true,
    });
    (0, utils_js_1.checkType)(pageContext);
    return pageContext;
}
function getPageContextSkipRequest(pageContextInit) {
    const urlPathnameWithBase = (0, utils_js_1.parseUrl)(pageContextInit.urlOriginal, '/').pathname;
    assertIsNotViteRequest(urlPathnameWithBase, pageContextInit.urlOriginal);
    let errMsg404;
    if (urlPathnameWithBase.endsWith('/favicon.ico')) {
        errMsg404 = 'No favicon.ico found';
    }
    if (urlPathnameWithBase.endsWith('.well-known/appspecific/com.chrome.devtools.json')) {
        // https://chromium.googlesource.com/devtools/devtools-frontend/+/main/docs/ecosystem/automatic_workspace_folders.md
        // https://www.reddit.com/r/node/comments/1kcr0wh/odd_request_coming_into_my_localhost_server_from/
        errMsg404 = 'Not supported';
    }
    if (!errMsg404)
        return;
    const pageContext = (0, createPageContextServerSide_js_1.createPageContextServerSideWithoutGlobalContext)(pageContextInit);
    const httpResponse = (0, createHttpResponse_js_1.createHttpResponse404)(errMsg404);
    (0, utils_js_1.objectAssign)(pageContext, { httpResponse });
    (0, utils_js_1.checkType)(pageContext);
    return pageContext;
}
function getPageContextInvalidVikeConfig(err, pageContextInit, httpRequestId) {
    (0, loggerRuntime_js_1.logRuntimeInfo)?.(picocolors_1.default.bold(picocolors_1.default.red('Error loading Vike config â€” see error above')), httpRequestId, 'error');
    const pageContextWithError = getPageContextHttpResponseErrorWithoutGlobalContext(err, pageContextInit);
    return pageContextWithError;
}
// Create pageContext forks to avoid leaks: upon an error (bug or abort) a brand new pageContext object is created, in order to avoid previous pageContext modifications that are now obsolete to leak to the new pageContext object.
function forkPageContext(pageContextBegin) {
    const pageContext = {};
    (0, utils_js_1.objectAssign)(pageContext, pageContextBegin, true);
    return pageContext;
}
