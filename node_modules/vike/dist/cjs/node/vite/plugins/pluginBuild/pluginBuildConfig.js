"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginBuildConfig = pluginBuildConfig;
exports.assertRollupInput = assertRollupInput;
exports.analyzeClientEntries = analyzeClientEntries;
const utils_js_1 = require("../../utils.js");
const resolveVikeConfigInternal_js_1 = require("../../shared/resolveVikeConfigInternal.js");
const findPageFiles_js_1 = require("../../shared/findPageFiles.js");
const virtualFileId_js_1 = require("../../../shared/virtualFileId.js");
const extractAssetsQuery_js_1 = require("../../../shared/extractAssetsQuery.js");
const prependEntriesDir_js_1 = require("../../../shared/prependEntriesDir.js");
const getFilePath_js_1 = require("../../shared/getFilePath.js");
const getConfigValueBuildTime_js_1 = require("../../../../shared/page-configs/getConfigValueBuildTime.js");
const isViteServerSide_js_1 = require("../../shared/isViteServerSide.js");
const handleAssetsManifest_js_1 = require("./handleAssetsManifest.js");
const retrievePageAssetsProd_js_1 = require("../../../runtime/renderPage/getPageAssets/retrievePageAssetsProd.js");
function pluginBuildConfig() {
    let config;
    return [
        {
            name: 'vike:build:pluginBuildConfig',
            apply: 'build',
            enforce: 'post',
            configResolved: {
                order: 'post',
                async handler(config_) {
                    (0, utils_js_1.onSetupBuild)();
                    config = config_;
                    assertRollupInput(config);
                    const entries = await getEntries(config);
                    (0, utils_js_1.assert)(Object.keys(entries).length > 0);
                    config.build.rollupOptions.input = (0, utils_js_1.injectRollupInputs)(entries, config);
                    addLogHook();
                    (0, handleAssetsManifest_js_1.handleAssetsManifest_assertUsageCssCodeSplit)(config);
                },
            },
            config: {
                order: 'post',
                async handler() {
                    (0, utils_js_1.onSetupBuild)();
                    const build = await (0, handleAssetsManifest_js_1.handleAssetsManifest_getBuildConfig)();
                    return { build };
                },
            },
            buildStart() {
                (0, utils_js_1.onSetupBuild)();
            },
        },
    ];
}
async function getEntries(config) {
    const vikeConfig = await (0, resolveVikeConfigInternal_js_1.getVikeConfigInternal)();
    const { _pageConfigs: pageConfigs } = vikeConfig;
    // TO-DO/next-major-release: remove
    const pageFileEntries = await getPageFileEntries(config, (0, retrievePageAssetsProd_js_1.resolveIncludeAssetsImportedByServer)(vikeConfig.config));
    (0, utils_js_1.assertUsage)(Object.keys(pageFileEntries).length !== 0 || pageConfigs.length !== 0, 'At least one page should be defined, see https://vike.dev/add');
    if ((0, isViteServerSide_js_1.isViteServerSide_viteEnvOptional)(config)) {
        const pageEntries = getPageEntries(pageConfigs);
        const entries = {
            ...pageFileEntries,
            // Ensure Rollup generates a bundle per page: https://github.com/vikejs/vike/issues/349#issuecomment-1166247275
            ...pageEntries,
        };
        return entries;
    }
    else {
        let { hasClientRouting, hasServerRouting, clientEntries } = analyzeClientEntries(pageConfigs, config);
        if (Object.entries(pageFileEntries).length > 0) {
            hasClientRouting = true;
            hasServerRouting = true;
        }
        const entries = {
            ...clientEntries,
            ...pageFileEntries,
        };
        const clientRoutingEntry = (0, utils_js_1.requireResolveDistFile)('dist/esm/client/runtime-client-routing/entry.js');
        const serverRoutingEntry = (0, utils_js_1.requireResolveDistFile)('dist/esm/client/runtime-server-routing/entry.js');
        if (hasClientRouting) {
            entries['entries/entry-client-routing'] = clientRoutingEntry;
        }
        if (hasServerRouting) {
            entries['entries/entry-server-routing'] = serverRoutingEntry;
        }
        return entries;
    }
}
function getPageEntries(pageConfigs) {
    const pageEntries = {};
    pageConfigs.forEach((pageConfig) => {
        const { entryName, entryTarget } = getEntryFromPageConfig(pageConfig, false);
        pageEntries[entryName] = entryTarget;
    });
    return pageEntries;
}
function analyzeClientEntries(pageConfigs, config) {
    let hasClientRouting = false;
    let hasServerRouting = false;
    let clientEntries = {};
    let clientEntryList = [];
    pageConfigs.forEach((pageConfig) => {
        const configValue = (0, getConfigValueBuildTime_js_1.getConfigValueBuildTime)(pageConfig, 'clientRouting', 'boolean');
        if (configValue?.value) {
            hasClientRouting = true;
        }
        else {
            hasServerRouting = true;
        }
        {
            // Ensure Rollup generates a bundle per page: https://github.com/vikejs/vike/issues/349#issuecomment-1166247275
            const { entryName, entryTarget } = getEntryFromPageConfig(pageConfig, true);
            clientEntries[entryName] = entryTarget;
        }
        {
            const clientEntry = (0, getConfigValueBuildTime_js_1.getConfigValueBuildTime)(pageConfig, 'client', 'string')?.value ?? null;
            if (clientEntry) {
                clientEntryList.push(clientEntry);
            }
        }
    });
    clientEntryList = (0, utils_js_1.unique)(clientEntryList);
    clientEntryList.forEach((clientEntry) => {
        const { entryName, entryTarget } = getEntryFromClientEntry(clientEntry, config);
        clientEntries[entryName] = entryTarget;
    });
    return { hasClientRouting, hasServerRouting, clientEntries };
}
// Ensure Rollup creates entries for each page file, see https://github.com/vikejs/vike/issues/350
// (Otherwise the page files may be missing in the client manifest.json)
async function getPageFileEntries(config, includeAssetsImportedByServer) {
    const isForClientSide = !(0, isViteServerSide_js_1.isViteServerSide_viteEnvOptional)(config);
    const fileTypes = isForClientSide ? ['.page', '.page.client'] : ['.page', '.page.server'];
    if (isForClientSide && includeAssetsImportedByServer) {
        fileTypes.push('.page.server');
    }
    let pageFiles = await (0, findPageFiles_js_1.findPageFiles)(config, fileTypes, false);
    const pageFileEntries = {};
    pageFiles = (0, utils_js_1.unique)(pageFiles);
    pageFiles.forEach((pageFile) => {
        let addExtractAssetsQuery = false;
        if (isForClientSide && pageFile.includes('.page.server.')) {
            (0, utils_js_1.assert)(includeAssetsImportedByServer);
            addExtractAssetsQuery = true;
        }
        const { entryName, entryTarget } = getEntryFromClientEntry(pageFile, config, addExtractAssetsQuery);
        pageFileEntries[entryName] = entryTarget;
    });
    return pageFileEntries;
}
function getEntryFromClientEntry(clientEntry, config, addExtractAssetsQuery) {
    if (!clientEntry.startsWith('/')) {
        (0, utils_js_1.assertIsImportPathNpmPackage)(clientEntry);
        const entryTarget = clientEntry;
        const entryName = (0, prependEntriesDir_js_1.prependEntriesDir)(clientEntry);
        return { entryName, entryTarget };
    }
    const filePathAbsoluteUserRootDir = clientEntry;
    (0, utils_js_1.assert)(filePathAbsoluteUserRootDir.startsWith('/'));
    const filePath = (0, getFilePath_js_1.getFilePathResolved)({
        filePathAbsoluteUserRootDir,
        userRootDir: config.root,
    });
    let entryTarget = filePath.filePathAbsoluteFilesystem;
    if (addExtractAssetsQuery)
        entryTarget = (0, extractAssetsQuery_js_1.extractAssetsAddQuery)(entryTarget);
    let entryName = filePathAbsoluteUserRootDir;
    if (addExtractAssetsQuery)
        entryName = (0, extractAssetsQuery_js_1.extractAssetsAddQuery)(entryName);
    entryName = (0, utils_js_1.removeFileExtension)(entryName);
    entryName = (0, prependEntriesDir_js_1.prependEntriesDir)(entryName);
    return { entryName, entryTarget };
}
function getEntryFromPageConfig(pageConfig, isForClientSide) {
    let { pageId } = pageConfig;
    const entryTarget = (0, virtualFileId_js_1.generateVirtualFileId)({ type: 'page-entry', pageId, isForClientSide });
    let entryName = pageId;
    // Avoid:
    // ```
    // dist/client/assets/entries/.Dp9wM6PK.js
    // dist/server/entries/.mjs
    // ```
    if (entryName === '/')
        entryName = 'root';
    entryName = (0, prependEntriesDir_js_1.prependEntriesDir)(entryName);
    (0, utils_js_1.assert)(!entryName.endsWith('/'));
    return { entryName, entryTarget };
}
function addLogHook() {
    const tty = process.stdout.isTTY && !process.env.CI; // Equals https://github.com/vitejs/vite/blob/193d55c7b9cbfec5b79ebfca276d4a721e7de14d/packages/vite/src/node/plugins/reporter.ts#L27
    if (!tty)
        return;
    let lastLog = null;
    ['stdout', 'stderr'].forEach((stdName) => {
        var methodOriginal = process[stdName].write;
        process[stdName].write = function (...args) {
            lastLog = String(args[0]);
            return methodOriginal.apply(process[stdName], args);
        };
    });
    // Exhaustive list extracted from writeLine() calls at https://github.com/vitejs/vite/blob/193d55c7b9cbfec5b79ebfca276d4a721e7de14d/packages/vite/src/node/plugins/reporter.ts
    // prettier-ignore
    // biome-ignore format:
    const viteTransientLogs = [
        'transforming (',
        'rendering chunks (',
        'computing gzip size ('
    ];
    (0, utils_js_1.addOnBeforeLogHook)(() => {
        // Using viteTransientLogs is very conservative as clearing the current line is low risk. (We can assume that important messages, such as errors, include a trailing new line. Usually, only transient messages have no trailing new lines.)
        if (viteTransientLogs.some((s) => lastLog?.startsWith(s))) {
            process.stdout.clearLine(0);
            process.stdout.cursorTo(0);
        }
    });
}
function assertRollupInput(config) {
    const userInputs = (0, utils_js_1.normalizeRollupInput)(config.build.rollupOptions.input);
    const htmlInputs = Object.values(userInputs).filter((entry) => entry.endsWith('.html') || entry.endsWith('.htm'));
    const htmlInput = htmlInputs[0];
    (0, utils_js_1.assertUsage)(htmlInput === undefined, `The entry ${htmlInput} of config build.rollupOptions.input is an HTML entry which is forbidden when using Vike, instead follow https://vike.dev/add`);
}
